
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Grisha Trubetskoy</title>
  <meta name="author" content="Gregory Trubetskoy">

  
  <meta name="description" content="It’s been over a year since I began hacking on
Tgres. Tgres came about when I first
decided to dive into Go. Go can do great
stuff, but I didn’t see &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://grisha.org">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Grisha Trubetskoy" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<!-- MathJax -->
<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
  });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42971867-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Grisha Trubetskoy</a></h1>
  
    <h2>Notes to self.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:grisha.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/07/29/state-of-tgres-2016/">Introducing Tgres - a Time Series DB on Top of PostgreSQL</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-07-29T10:12:00-04:00" pubdate data-updated="true">Jul 29<span>th</span>, 2016</time>
        
         | <a href="/blog/2016/07/29/state-of-tgres-2016/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>It’s been over a year since I began hacking on
<a href="http://github.com/tgres/tgres">Tgres</a>. Tgres came about when I first
decided to dive into <a href="https://golang.org/">Go</a>. Go can do great
stuff, but I didn’t see how it applied to anything I was working on at
the time. I needed a project that was a better match for the domain of
applications that Go aims for, something where performance and scale
matter, something with concurrent moving pieces, something
challenging. A “time series database” seemed like it had potential. It
has all kinds of curious requirements that could be great fun to
implement in Go.</p>

<h2 id="what-is-tgres">What is Tgres</h2>

<p>So Tgres is a metrics collection and storage server, aka a time series
database. I’m not very comfortable with referring to it as a
<em>database</em>, because at least in case of Tgres, the database is
actually PostgreSQL. But also “database” to me is in the same category
as “operating system” or “compiler”, a thing so advanced that only few
can claim to be it without appearing pretentious. But for the sake of
tautology avoidance, I might occasionally refer to Tgres as a TS
database.</p>

<p>Ulike <a href="https://graphiteapp.org/">Graphite</a> or
<a href="http://oss.oetiker.ch/rrdtool/">RRDTool</a>, Tgres produces no charts,
it assumes you’re using something like
<a href="http://grafana.org/">Grafana</a>. Currently Tgres supports most of the
Graphite functionality (including vast majority of the functions) as
well as Statsd functionality. Tgres supports clustering, albeit
whereby all nodes must share the PostgreSQL instance. Tgres can be
used as a standalone server or as a Go package compiled into your app.</p>

<h3 id="current-status">Current status</h3>

<p>Don’t get too excited just yet, Tgres is still not production quality,
though it’s probably stable enough for someone who knows their way
around Go to give it a whirl. At this point I have proven the
concept, and believe the architecture is sound, but the magnitude of
the project turned out to be much grater than I originally pictured,
and so it still needs lots and lots of proofreading, t’s crossed and
i’s dotted.</p>

<h2 id="raisons-detre">Raisons d’etre</h2>

<h3 id="present-state-of-time-series-databases-is-dismal">Present state of “time series databases” is dismal</h3>

<p>I was (and still am) frustrated with the state of TS in our
industry. Since the appearance of
<a href="http://oss.oetiker.ch/mrtg/doc/mrtg.en.html">MRTG</a> back in 1995 when
the network admins of the then burgeoning Internet realized that TS is
essential to device monitoring, not much has happened.</p>

<p><a href="http://oss.oetiker.ch/rrdtool/">RRDTool</a> was definitely a major step
forward from MRTG which was merely a Perl script. RRDTool to this day
is the best implementation of a round-robin database for time series
data (in C to boot). Similarly to MRTG, RRDTool was designed as a command-line tool,
the server component was left as an exercise for the user. And even
though linking RRDTool into your app was not too difficult (I <a href="https://github.com/grisha/openvps-common/blob/master/py-rrd/_RRD.c">did
it</a>
in 2004), somehow an “RRD server” never appeared.</p>

<p>Then there was <a href="https://graphiteapp.org/">Graphite</a>. (I think Graphite
is a reflection of the Python-can-do-anything era.) Graphite borrowed
a lot of ideas from RRDTool, though its re-implementation of
round-robin on-disk files in pure Python while <a href="http://graphite.wikidot.com/whisper">claiming superiority</a> is not that much
better, if at all, IMHO when compared to RRDTool in both accuracy and
performance. In general though, I think storing data directly in files
is the wrong approach to begin with.</p>

<p>Graphite’s appeal is that it’s an easy-to-start server that does
everything, and it became especially popular alongside
<a href="https://github.com/etsy/statsd/wiki">Statsd</a> a tool with umpteen
different implementation designed to sit in front of
Graphite. Eventually people stopped using Graphite to make charts
favoring instead the most excellent Grafana,
while Graphite (or its nephew <a href="https://github.com/brutasse/graphite-api">Graphite-API</a>)
became a UI-less server-only component to store and retrieve data.</p>

<p>Graphite and RRDTool didn’t scale very well, so for “Big Time Series”
(as in very large networks, or specialized fields like finance,
weather, etc.) people used solutions backed by
<a href="http://cassandra.apache.org/">Cassandra</a>, <a href="https://hbase.apache.org/">HBase</a>,
or <a href="http://lucene.apache.org/solr/">Solr</a> such as
<a href="http://opentsdb.net/">OpenTSDB</a>.</p>

<p>There are also new kids on the block such as
<a href="https://influxdata.com/">InfluxDB</a> or
<a href="https://prometheus.io/">Prometheus</a>, which are a little too flashy
and commercial by my taste, each trying to solve problems that I don’t
think I have.</p>

<p>Bottom line is that some 20 years after MRTG, time series remains
mostly a system monitoring aid and has never crossed over to the
mainstream application development.</p>

<h3 id="data-isolation">Data isolation</h3>

<p>Virtually all of the aforementioned tools contribute to a problem I
dub <em>data isolation</em>. Data isolation is when a part of our data is
stored using a separate tool in a different format and is therefore
not as easily accessible.  For example if our metrics are in Graphite,
we probably don’t even know how to get them out of it, nor does it
occur to us that it might be useful.  All we’ve been able to do is get
a Grafana chart and are quite satisfied with it. We do not question
why it isn’t a first-class citizen right in the database as a table,
where we could use it in SQL joins, for example. Or export it to our
big data rig and query it with Hive or Spark, etc.</p>

<p>Why is getting a quick chart of customer sign-ups per second next to
all my customer data such a big deal these days? Why can’t it be as
simple as a model in my Rails or Django app?</p>

<h3 id="postgresql---avoid-the-storage-mire">PostgreSQL - Avoid the storage mire</h3>

<p>I believe that there is nothing about time series that makes it unfit
for a relational database. Many projects out there are spinning
their wheels solving the wrong problem, that of data storage. Storage
is one of the hardest problems in computers, time series databases
should focus on time series and delegate the storage to tried-and-true
tools which are good at it.</p>

<p>Time series data does carry certain special requirements, and I’ve
researched extensively all different ways TS can be stored in a
relational database. It does require taking advantage of some newer
features that in the open source database world seem most available in
PostgreSQL. I am guessing that with time these capabilities will
become more available in other databases, and some of them already
are, but for the time being I’ve decided that Tgres is
PostgreSQL-only.</p>

<h2 id="a-bit-of-detail">A bit of detail</h2>

<h3 id="emulating-graphite-as-a-starting-point">Emulating Graphite as a starting point</h3>

<p>I would like Tgres to be useful. The simplest way I could think of
achieving usefulness is by emulating an existing tool so that it can
become a drop-in replacement. This makes adoption easy and it also
proves that the underlying architecture is capable. It also lets us
compare performance.</p>

<p>It doesn’t mean that I am a fan of how Graphite does things, but I
think that if Tgres is architected in such a way that there is a lower
level which does the heavy lifting and then a layer on top of it that
makes it behave like Graphite, that’s a great start, and it leaves
options open for potential improvement and a different/better
interface.</p>

<h3 id="general-terminology">General terminology</h3>

<p>I always liked how RRDTool documentation broke down the problem of
time series into concise and clear terms. Tgres tries to leverage the
RRDTool terminology. Tgres also adopts the same techniques to the
extent that is possible given a considerably different
architecuture. Unlike RRDTool, Tgres uses a millisecond as the
smallest unit of time measure.</p>

<h4 id="data-point-dp">Data Point (DP)</h4>

<p>A <em>data point</em> is a <em>value</em> (a floating point number) a <em>time stamp</em>
and a string <em>name</em> identifying the series. (For a while I
contemplated allowing a data point to have multiple values, but it
made things too complicated, so I reverted to a single value per data
point).</p>

<h4 id="round-robin-archive-rra">Round-Robin Archive (RRA)</h4>

<p>Tgres stores data points in <em>round-robin archives</em>.  While
“round-robin” is an implementation detail, it is part of the name
because the only way it can be round-robin is the number of data
points in the archive is constant. The size of the RRA is determined
by the <em>step</em> (resolution) and the size of the archive. Thus RRA’s are
defined by step and size, e.g. 10s for 24 hours (a data point every
10s for 24 hours, or 8,640 points).</p>

<p>A series is usually is stored in multiple RRA’s. The RRA’s typically
have varying resolutions, e.g. we want a 10s step for the past 24h,
but also a 1h step for a week and a 6h step for 3 years. In this
example we have 3 RRA’s. Tgres takes care of maintaining the RRA’s and
selecting the right resultion for a given query so that there is no
need to deal with individual RRA’s directly.</p>

<h4 id="data-source-ds">Data Source (DS)</h4>

<p>A group of RRA’s under the same identifier (aka series name) is
referred to as a data source (DS). I suppose “DS” can be used
interchangeably with “series”. Depending on how Tgres is configured,
DS’s are either predefined or are created on the fly based on DS name
matching rules.</p>

<p>Note that Tgres does not store the original data points, but only the
weighted averages of the received data points in each RRA. This is how
RRDTool does it. Graphite doesn’t bother averaging the points but
simply discards previous data points within the same step. At first it
may seem not ideal that the original data is discarded, but experience
shows that just about any time series operation results in a
conversion to a fixed interval form as the first step, so it might as
well just be done upfront.</p>

<h4 id="heartbeat-hb">Heartbeat (HB)</h4>

<p>Every DS has a <em>heartbeat</em>, a time duration which defines the longest
possible period of inactivity before the DS becomes considered
dysfunctional. If the heartbeat is exceeded, the data since the last
update will be recorded as NaNs.</p>

<h4 id="xfiles-factor-xff">Xfiles factor (XFF)</h4>

<p>When data is consolidated from smaller to larger step RRAs, the XFF
determines how much of the data is allowed to be NaN before the
consolidated value becomes NaN. For example if we are consolidating
per-minute values into a per-hour value, if one of the minutes happens
to be NaN, strictly speaking the whole hour ought ot be NaN, but that
wouldn’t be very useful. Default XFF is .5, i.e. more than half of the
per-minute values should be NaN before the per-hour value is
considered NaN.</p>

<h3 id="postgres-storage-format">Postgres storage format</h3>

<p>A time series is a series of floats. Note that when it’s stored in
RRA’s, there is no need for timestamps - each position in an RRA has
its timestamp defined by the current state of the RRA. If we know the
timestamp of the tip, we know the timestamp of every element going
back to the beginning of the RRA.</p>

<p>To store data points Tgres takes advantage of PostgreSQL arrays. A
single row stores many data points. Tgres further splits series into
multiple rows to optimize the IO.</p>

<p>To make the data easy to use, Tgres also creates a view which makes
the data points structured as a regular table with a row per data
point.</p>

<p>There are only 3 tables and 1 view required for Tgres operation. You
can use the same database you use for any other web app you have. This
means you can access the time series by simply just adding a model
pointing at the Tgres time series view to your Rails/Django/whatever
to get access to the data.</p>

<h2 id="tgres-components">Tgres components</h2>

<p>Tgres is organized as a set of Go packages.</p>

<h3 id="tgresdaemon">tgres/daemon</h3>

<p>The <a href="https://github.com/tgres/tgres/tree/master/daemon">daemon</a> is the
main process that runs everything. It includes the config parser, and
the listeners that receive and parse incoming data points using both
UDP and TCP Graphite formats, as well as Python Pickle format (though
I’m not sure who out there really uses it). It’s not too hard to add
more formats, for example I think it’d be neat if Tgres could receive
data points via an HTTP pixel that could be embedded in web pages.</p>

<p>The daemon also takes care of graceful restarts, logging and other
typical long-running service stuff.</p>

<h3 id="trgestranceiver">trges/tranceiver</h3>

<p>The<a href="https://github.com/tgres/tgres/tree/master/transceiver">transceiver</a>
is the data point router and cache. It maintains a set of workers
responsible for writing the data points to their respective RRA’s, as
well as caching and periodic flushing of the cache. Flushing is done
once a certian number of points has accumulated or a period of time
has passed, but not more often than the minimal flush frequency (all
configurable).</p>

<h3 id="tgresrrd">tgres/rrd</h3>

<p>The responsibility of <a href="https://github.com/tgres/tgres/tree/master/rrd">rrd</a> is to add data
points to RRA’s. This is not as simple as it sounds, a good
description of the concepts behind it is available here:
http://rrdtool.vandenbogaerdt.nl/process.php#Rate</p>

<h3 id="tgreshttp">tgres/http</h3>

<p><a href="https://github.com/tgres/tgres/tree/master/http">http</a> is the place
for all things related to HTTP, which currently is just the Graphite
API. The API requests are passed down to the DSL level for processing.</p>

<h3 id="tgresdsl">tgres/dsl</h3>

<p><a href="https://github.com/tgres/tgres/tree/master/dsl">dsl</a> is an
implementation of the Graphite
<a href="http://graphite.readthedocs.io/en/latest/functions.html">functions</a>. There
are a few differences because I used the Go parser which is nearly
syntactically identical. (For example a series name cannot begin with
a digit because that is not a proper Go identifier).</p>

<p>Graphite has a lot number of functions available in its DSL, and I
spent a lot of time during our beach vacation last summer trying to
implement them all, but I think a few are still left undone. Some were
harder than others, and some led me on side adventures such as
figuring out the Holt-Winters triple exponential smoothing and how to
do it correctly. (ZZZ - link)</p>

<h3 id="tgresserde">tgres/serde</h3>

<p>The interface to the database is reduced to a fairly compact
<a href="https://github.com/tgres/tgres/tree/master/serde">SerDe</a>
(Serialize-Deserializer) interface. While the SerDe itself is utterly
simplistic (e.g. “get me this series”), the SQL behind it anything
but, still, it should be possible to throw together an alternative
SerDe for a different relational database (or not a database at all?).</p>

<h3 id="tgresstatsd">tgres/statsd</h3>

<p><a href="https://github.com/tgres/tgres/tree/master/statsd">Statsd</a> is currently
in a separate Go package, but I might integrate with the RRD because
it is not very clear that it needs to be a separate thing. Somehow it
so happened that Graphite and Statd are two separate projects, but the
reasons for this are probably more cultural than by design.</p>

<h3 id="tgrescluster">tgres/cluster</h3>

<p><a href="https://github.com/tgres/tgres/tree/master/cluster">Cluster</a> supports
very basic clustering. At this point it’s “good enough” given that
it’s OK to occasionally lose data points during cluster transitions
and all that we want to make sure of is that nodes can come and go
without disruptions.</p>

<p>The principle behind cluster is that each node is responsible for one
or more series and other nodes will forward data points to the
responsible node. There is nearly zero configuration, and any node can
act as the point of contact, i.e. there is no leader.</p>

<p>The way clustering is done is in flux at the moment, we might change
it to something more robust in the near future, but for the time being
it addresses the horizontal scaling problem.</p>

<h2 id="theres-still-lots-to-do">There’s still lots to do…</h2>

<p>There’s still a lot of work to be done on Tgres. For one thing, I
don’t have any tests. This is mainly because I don’t believe in
testing that which hasn’t “gelled”, and I wouldn’t be surprised if the
above organization of packages and how they interface changes as I
understand the problem better. We also need documentation. And some
real-life use/testing/feedback would be great as well.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/04/19/deploying-a-golang-app-to-aws-ecs-with-terraform/">Deploying a Golang App to AWS ECS With Terraform</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-04-19T10:53:00-04:00" pubdate data-updated="true">Apr 19<span>th</span>, 2016</time>
        
         | <a href="/blog/2016/04/19/deploying-a-golang-app-to-aws-ecs-with-terraform/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I’ve put together a basic example of a “Hello World” Go program which
runs in Amazon AWS Elastic Compute Service (ECS), which allows running
applications in Docker containers and has the ability to scale on
demand.</p>

<p>I initially wanted to write about the components of this system and
the tools you use to deploy your application, but soon realized that
this would make for an extremely long post, as the number of
components required for a simple “Hello World” is mind
boggling. However problematic it may seem, it’s par for the course,
this is what takes to run an application in our cloudy times.</p>

<p>I used <a href="https://github.com/hashicorp/terraform">Terraform</a> to build
all the AWS infrastructure. Initially I was skeptical on how well it
could accomplish such a tedious task, but I have say my confidence in
Terraform grew the more I used it.</p>

<p>The main top level tool for everything is the good old
<a href="https://en.wikipedia.org/wiki/Make_%28software%29">make</a>, a tool that
stood the test of time.</p>

<p>Here is the code of the example, read the README, I hope you find it
useful:</p>

<p><a href="https://github.com/grisha/hello-go-ecs-terraform">https://github.com/grisha/hello-go-ecs-terraform</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/02/17/triple-exponential-smoothing-forecasting-part-iii/">Holt-Winters Forecasting for Dummies - Part III</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-02-17T10:39:00-05:00" pubdate data-updated="true">Feb 17<span>th</span>, 2016</time>
        
         | <a href="/blog/2016/02/17/triple-exponential-smoothing-forecasting-part-iii/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>If you haven’t read <a href="/blog/2016/01/29/triple-exponential-smoothing-forecasting/">Part I</a> and
<a href="/blog/2016/02/16/triple-exponential-smoothing-forecasting-part-ii/">Part II</a>
you probably should, or the following will be hard to make sense of.</p>

<p>In Part I we’ve learned how to forceast one point, in Part II we’ve
learned how to forecast two points. In this part we’ll learn how to
forecast <em>many</em> points.</p>

<h2 id="more-terminology">More Terminology</h2>

<h3 id="season"><em>Season</em></h3>

<p>If a series appears to be repetitive at regular intervals, such an
interval is referred to as a <em>season</em>, and the series is said to be
<em>seasonal</em>. <a href="https://en.wikipedia.org/wiki/Seasonality">Seasonality</a>
is required for the Holt-Winters method to work, non-seasonal series
(e.g. stock prices) cannot be forecasted using this method (would be
nice though if they could be).</p>

<h3 id="season-length"><em>Season Length</em></h3>

<p><em>Season length</em> is the number of data points after which a new season
begins. We will use $L$ to denote season length.</p>

<h3 id="seasonal-component"><em>Seasonal Component</em></h3>

<p>The <em>seasonal component</em> is an additional deviation from level + trend
that repeats itself at the same offset into the season. There is a
seasonal component for every point in a season, i.e. if your season
length is 12, there are 12 seasonal components. We will use $s$ to
denote the seasonal component.</p>

<h2 id="triple-exponential-smoothing-aka-holt-winters-method">Triple Exponential Smoothing a.k.a Holt-Winters Method</h2>

<p>The idea behind triple exponential smoothing is to apply exponential
smoothing to the seasonal components in addition to level and
trend. The smoothing is applied across seasons, e.g. the seasonal
component of the 3rd point into the season would be exponentially
smoothed with the the one from the 3rd point of last season, 3rd point
two seasons ago, etc. In math notation we now have four equations (see footnote):</p>

<script type="math/tex; mode=display">% <![CDATA[

\begin{align}
& \ell_x = \alpha(y_x - s_{x-L}) + (1-\alpha)(\ell_{x-1} + b_{x-1})& \mbox{level} \\
& b_x = \beta(\ell_x - \ell_{x-1}) + (1-\beta)b_{x-1} & \mbox{trend} \\
& s_x = \gamma(y_x - \ell_x) + (1-\gamma)s_{x-L} & \mbox{seasonal} \\
& \hat{y}_{x+m} = \ell_x + mb_x + s_{x-L+1+(m-1)modL}& \mbox{forecast}\\
\end{align}
 %]]></script>

<ul>
  <li>What’s new:
    <ul>
      <li>We now have a third greek letter, $\gamma$ (gamma) which is the smoothing
factor for the seasonal component.</li>
      <li>The expected value index is $x+m$ where $m$ can be any integer meaning
we can forecast any number of points into the future (woo-hoo!)</li>
      <li>The forecast equation now consists of level, trend and the seasonal
component.</li>
    </ul>
  </li>
</ul>

<p>The index of the seasonal component of the forecast
$s_{x-L+1+(m-1)modL}$ may appear a little mind boggling, but it’s
just the offset into the list of seasonal components from the last set
from observed data. (I.e. if we are forecasting the 3rd point into the
season 45 seasons into the future, we cannot use seasonal components
from the 44th season in the future since that season is also
forecasted, we must use the last set of seasonal components from
observed points, or from “the past” if you will.) It looks much
simpler in Python as you’ll see shortly.</p>

<h3 id="initial-values">Initial Values</h3>

<p>Before we can discuss initial values, let me introduce to you a new
tiny series (okay, not as tiny):</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">series</span> <span class="o">=</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">29</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">48</span><span class="p">,</span><span class="mi">53</span><span class="p">,</span><span class="mi">47</span><span class="p">,</span><span class="mi">37</span><span class="p">,</span><span class="mi">39</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">29</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">27</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">41</span><span class="p">,</span><span class="mi">38</span><span class="p">,</span>
</span><span class="line">          <span class="mi">27</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">27</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span>
</span><span class="line">          <span class="mi">26</span><span class="p">,</span><span class="mi">29</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">28</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">46</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">28</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">27</span><span class="p">,</span>
</span><span class="line">          <span class="mi">18</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">34</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">38</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">32</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This is what it looks like:</p>

<p><img src="/images/hw04.png" /></p>

<p>You can see that this series is seasonal, there are clearly visible 6
seasons. Although perhaps not easily apparent from the picture, the
season length for this series is 12, i.e. it “repeats” every 12
points. In order to apply triple exponential smoothing we need to know
what the season length is. (There do exist methods for detecting
seasonality in series, but this is way beyond the scope of this text).</p>

<h4 id="initial-trend">Initial Trend</h4>

<p>For double exponential smoothing we simply used the first two points
for the initial trend. With seasonal data we can do better than that,
since we can observe many seasons and can extrapolate a better
starting trend. The most common practice is to compute the average of
trend averages across seasons.</p>

<script type="math/tex; mode=display">
b_0 = \dfrac{1}{L}\left(\dfrac{y_{L+1}-y_1}{L}+\dfrac{y_{L+2}-y_2}{L}+...+\dfrac{y_{L+L}-y_L}{L}\right)
</script>

<p>Good news - this looks simpler in Python than in math notation:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">initial_trend</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">slen</span><span class="p">):</span>
</span><span class="line">    <span class="nb">sum</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">slen</span><span class="p">):</span>
</span><span class="line">        <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">slen</span><span class="p">]</span> <span class="o">-</span> <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">slen</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">sum</span> <span class="o">/</span> <span class="n">slen</span>
</span><span class="line">
</span><span class="line"><span class="c"># &gt;&gt;&gt; initial_trend(series, 12)</span>
</span><span class="line"><span class="c"># -0.7847222222222222</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="initial-seasonal-components">Initial Seasonal Components</h4>

<p>The situation is even more complicated when it comes to initial values
for the seasonal components. Briefly, we need to compute the average
level for every observed season we have, divide every observed value
by the average for the season it’s in and finally average each of
these numbers across our observed seasons. If you want more detail, here is
<a href="http://www.itl.nist.gov/div898/handbook/pmc/section4/pmc435.htm">one thorough description of this process</a>.</p>

<p>I will forgo the math notation for initial seasonal components, but
here it is in Python. The result is a season-length array of seasonal components.</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">initial_seasonal_components</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">slen</span><span class="p">):</span>
</span><span class="line">    <span class="n">seasonals</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line">    <span class="n">season_averages</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line">    <span class="n">n_seasons</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)</span><span class="o">/</span><span class="n">slen</span><span class="p">)</span>
</span><span class="line">    <span class="c"># compute season averages</span>
</span><span class="line">    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_seasons</span><span class="p">):</span>
</span><span class="line">        <span class="n">season_averages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="n">slen</span><span class="o">*</span><span class="n">j</span><span class="p">:</span><span class="n">slen</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="n">slen</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">slen</span><span class="p">))</span>
</span><span class="line">    <span class="c"># compute initial values</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">slen</span><span class="p">):</span>
</span><span class="line">        <span class="n">sum_of_vals_over_avg</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class="line">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_seasons</span><span class="p">):</span>
</span><span class="line">            <span class="n">sum_of_vals_over_avg</span> <span class="o">+=</span> <span class="n">series</span><span class="p">[</span><span class="n">slen</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">season_averages</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span><span class="line">        <span class="n">seasonals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_of_vals_over_avg</span><span class="o">/</span><span class="n">n_seasons</span>
</span><span class="line">    <span class="k">return</span> <span class="n">seasonals</span>
</span><span class="line">
</span><span class="line"><span class="c"># &gt;&gt;&gt; initial_seasonal_components(series, 12)</span>
</span><span class="line"><span class="c"># {0: -7.4305555555555545, 1: -15.097222222222221, 2: -7.263888888888888, 3: -5.097222222222222, 4: 3.402777777777778, 5: 8.069444444444445, 6: 16.569444444444446, 7: 9.736111111111112, 8: -0.7638888888888887, 9: 1.902777777777778, 10: -3.263888888888889, 11: -0.7638888888888887}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="the-algorithm">The Algorithm</h3>

<p>And finally, here is the additive Holt-Winters method in Python. The
arguments to the function are the series of observed values, the
season length, alpha, beta, gamma and the number of points we want
forecasted.:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">triple_exponential_smoothing</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">slen</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">n_preds</span><span class="p">):</span>
</span><span class="line">    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line">    <span class="n">seasonals</span> <span class="o">=</span> <span class="n">initial_seasonal_components</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">slen</span><span class="p">)</span>
</span><span class="line">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)</span><span class="o">+</span><span class="n">n_preds</span><span class="p">):</span>
</span><span class="line">        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># initial values</span>
</span><span class="line">            <span class="n">smooth</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span class="line">            <span class="n">trend</span> <span class="o">=</span> <span class="n">initial_trend</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">slen</span><span class="p">)</span>
</span><span class="line">            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span class="line">            <span class="k">continue</span>
</span><span class="line">        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">):</span> <span class="c"># we are forecasting</span>
</span><span class="line">            <span class="n">m</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class="line">            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">smooth</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">trend</span><span class="p">)</span> <span class="o">+</span> <span class="n">seasonals</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="n">slen</span><span class="p">])</span>
</span><span class="line">        <span class="k">else</span><span class="p">:</span>
</span><span class="line">            <span class="n">val</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class="line">            <span class="n">last_smooth</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">val</span><span class="o">-</span><span class="n">seasonals</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="n">slen</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">smooth</span><span class="o">+</span><span class="n">trend</span><span class="p">)</span>
</span><span class="line">            <span class="n">trend</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="p">(</span><span class="n">smooth</span><span class="o">-</span><span class="n">last_smooth</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">trend</span>
</span><span class="line">            <span class="n">seasonals</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="n">slen</span><span class="p">]</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">val</span><span class="o">-</span><span class="n">smooth</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">gamma</span><span class="p">)</span><span class="o">*</span><span class="n">seasonals</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="n">slen</span><span class="p">]</span>
</span><span class="line">            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">smooth</span><span class="o">+</span><span class="n">trend</span><span class="o">+</span><span class="n">seasonals</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="n">slen</span><span class="p">])</span>
</span><span class="line">    <span class="k">return</span> <span class="n">result</span>
</span><span class="line">
</span><span class="line"><span class="c"># # forecast 24 points (i.e. two seasons)</span>
</span><span class="line"><span class="c"># &gt;&gt;&gt; triple_exponential_smoothing(series, 12, 0.716, 0.029, 0.993, 24)</span>
</span><span class="line"><span class="c"># [30, 20.34449316666667, 28.410051892109554, 30.438122252647577, 39.466817731253066, ...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>And here is what this looks like if we were to plot the original
series, followed by the last 24 points from the result of the
<code>triple_exponential_smoothing()</code> call:</p>

<p><img src="/images/hw05.png" /></p>

<h3 id="a-note-on---and-">A Note on α, β and γ</h3>

<p>You may be wondering how I came up with 0.716, 0.029 and 0.993 for
$\alpha$, $\beta$ and $\gamma$, respectively. To make long story short, it
was done by way of trial and error: simply running the algorithm over and
over again and selecting the values that give you the smallest
<a href="https://en.wikipedia.org/wiki/Residual_sum_of_squares">SSE</a>. As I
mentioned before, this process is known as <em>fitting</em>.</p>

<p>To compute the smothing factors to three decimal points
we may have to run through 1,000,000,000 iterations, but luckily
there are more efficient methods at zooming in on best
values. Unfortunately this would take a whole other very long post to
describe this process. One good algorithm for this is
<a href="https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method">Nelder-Mead</a>,
which is what <a href="https://github.com/tgres/tgres">tgres</a> uses.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Well - here you have it, Holt-Winters method explained the way I wish
it would have been explained to me when I needed it. If you think I
missed something, found an error or a suggestion, please do not
hesitate to comment!</p>

<h2 id="footnote">Footnote</h2>

<p>The triple exponential smoothing additive method formula is as it is
described in “Forecasting Method and Applications, Third Edition” by
Makridakis, Wheelwright and Hyndman (1998). <a href="https://en.wikipedia.org/wiki/Exponential_smoothing#Triple_exponential_smoothing">Wikipedia</a> has a different
formula for the seasonal component (I don’t know which is better):</p>

<script type="math/tex; mode=display">% <![CDATA[

\begin{align}
& s_x = \gamma(y_x - \ell_{x-1} - b_{x-1}) + (1-\gamma)s_{x-L} & \mbox{seasonal} \\
\end{align}
 %]]></script>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/02/16/triple-exponential-smoothing-forecasting-part-ii/">Holt-Winters Forecasting for Dummies - Part II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-02-16T13:05:00-05:00" pubdate data-updated="true">Feb 16<span>th</span>, 2016</time>
        
         | <a href="/blog/2016/02/16/triple-exponential-smoothing-forecasting-part-ii/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>If you haven’t read <a href="/blog/2016/01/29/triple-exponential-smoothing-forecasting/">Part I</a>
you probably should, or the following will be hard to make sense of.</p>

<p>All the forecasting methods we covered so far, including single
exponential smoothing, were only good at predicting a single
point. We can do better than that, but first we need to agree
on a couple of more terms.</p>

<h2 id="more-terminology">More terminology</h2>

<h3 id="level"><em>Level</em></h3>

<p>Expected value has another name, which, again varies depending on who wrote the
text book: <em>baseline</em>, <em>intercept</em> (as in
<a href="https://en.wikipedia.org/wiki/Y-intercept">Y-intercept</a>) or
<em>level</em>. We will stick with “level” here.</p>

<p>So level is that one predicted point that we learned how to calculate
in Part I. But because now it’s going to be only part of calculation
of the forcast, we can no longer refer to it as $\hat{y}$ and will instead
use $\ell$.</p>

<h3 id="trend-or-slope"><em>Trend</em> or <em>Slope</em></h3>

<p>You should be familiar with
<a href="https://en.wikipedia.org/wiki/Slope">slope</a> from your high school algebra
class. What you might be a little rusty on is how to calculate it,
which is important, because a series slope has an interesting
characteristic. Slope is:</p>

<script type="math/tex; mode=display">
m = \dfrac{\Delta{y}} {\Delta{x}}
</script>

<p>where $\Delta{y}$ is the difference in the $y$ coordinates and
$\Delta{x}$ is the difference in the $x$ coordinates, respectively,
between two points. While in real algebraic problems $\Delta{x}$ could
be anything, in a series, from one point to the next, it is always
1. Which means that for a series, slope between two adjacent points
is simply $\dfrac{\Delta{y}} {1}$ or $\Delta{y}$, or:</p>

<script type="math/tex; mode=display">
b = y_x - y_{x-1}
</script>

<p>Where $b$ is <em>trend</em>. To the best of my understanding terms “trend”
and “slope” are interchangeable. In forecasting parlance “trend” is
more common, and in math notation forecasters refer to it as $b$
rather than $m$.</p>

<h4 id="additive-vs-multiplicative">Additive vs Multiplicative</h4>

<p>Another thing to know about trend is that instead of subtracting
$y_{x-1}$ from $y_x$, we could divide one by the other thereby
getting a ratio. The difference between these two approaches is
similar to how we can say that something costs $20 more or 5%
more. The variant of the method based on subtraction is known as
<em>additive</em>, while the one based on division is known as
<em>multiplicative</em>.</p>

<p>Practice shows that a ratio (i.e. multiplicative) is a more stable
predictor. The additive method, however is simpler to understand, and
going from additive to multiplicative is trivial once you understand
this whole thing. For this reason we will stick with the additive
method here, leaving the multiplicative method an exercise for the
reader.</p>

<h2 id="double-exponential-smoothing">Double Exponential Smoothing</h2>

<p>So now we have two components to a series: level and trend. In Part I
we learned several methods to forecast the level, and it should follow
that every one of these methods can be applied to the trend
just as well. E.g. the naive method would assume that trend between
last two points is going to stay the same, or we could average all
slopes between all points to get an average trend, use a moving trend
average or apply exponential smoothing.</p>

<p>Double exponential smoothing then is nothing more than exponential
smoothing applied to both level and trend. To express this in
mathematical notation we now need three equations: one for level, one
for the trend and one to combine the level and trend to get the
expected $\hat{y}$.</p>

<script type="math/tex; mode=display">% <![CDATA[

\begin{align}
& \ell_x = \alpha y_x + (1-\alpha)(\ell_{x-1} + b_{x-1})& \mbox{level} \\
& b_x = \beta(\ell_x - \ell_{x-1}) + (1-\beta)b_{x-1} & \mbox{trend} \\
& \hat{y}_x = \ell_x + b_x & \mbox{forecast}\\
\end{align}
 %]]></script>

<p>The first equation is from Part I, only now we’re using $\ell$ instead
of $\hat{y}$ and on the right side the expected value becomes the sum
of level end trend.</p>

<p>The second equation introduces $\beta$, the <em>trend factor</em> (or
coefficient). As with $\alpha$, some values of ${\beta}$ work better
than others depending on the series.</p>

<p>Similarly to single exponential smoothing, where we used the first
observed value as the first expected, we can use the first observed
trend as the first expected. Of course we need at least two points to
compute the initial trend.</p>

<p>Because we have a level and a trend, this method can forecast not one,
but two data points. In Python:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># given a series and alpha, return series of smoothed points</span>
</span><span class="line"><span class="k">def</span> <span class="nf">double_exponential_smoothing</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
</span><span class="line">    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</span><span class="line">    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
</span><span class="line">        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span><span class="line">            <span class="n">level</span><span class="p">,</span> <span class="n">trend</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">series</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span class="line">        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">):</span> <span class="c"># we are forecasting</span>
</span><span class="line">          <span class="n">value</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span><span class="line">        <span class="k">else</span><span class="p">:</span>
</span><span class="line">          <span class="n">value</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</span><span class="line">        <span class="n">last_level</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">,</span> <span class="n">alpha</span><span class="o">*</span><span class="n">value</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">level</span><span class="o">+</span><span class="n">trend</span><span class="p">)</span>
</span><span class="line">        <span class="n">trend</span> <span class="o">=</span> <span class="n">beta</span><span class="o">*</span><span class="p">(</span><span class="n">level</span><span class="o">-</span><span class="n">last_level</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">trend</span>
</span><span class="line">        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">level</span><span class="o">+</span><span class="n">trend</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="n">result</span>
</span><span class="line">
</span><span class="line"><span class="c"># &gt;&gt;&gt; double_exponential_smoothing(series, alpha=0.9, beta=0.9)</span>
</span><span class="line"><span class="c"># [3, 17.0, 15.45, 14.210500000000001, 11.396044999999999, 8.183803049999998, 12.753698384500002, 13.889016464000003]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>And here is a picture of double exponential smoothing in action (the
green dotted line).</p>

<p><img src="/images/hw03.png" /></p>

<h2 id="quick-review">Quick Review</h2>

<p>We’ve learned that a data point in a series can be represented as a
level and a trend, and we have learned how to appliy exponential
smoothing to each of them to be able to forecast not one, but two
points.</p>

<p>In <a href="/blog/2016/02/17/triple-exponential-smoothing-forecasting-part-iii/">Part III</a>
we’ll finally talk about triple exponential smoothing.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/29/triple-exponential-smoothing-forecasting/">Holt-Winters Forecasting for Dummies (or Developers) - Part I</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-01-29T15:36:00-05:00" pubdate data-updated="true">Jan 29<span>th</span>, 2016</time>
        
         | <a href="/blog/2016/01/29/triple-exponential-smoothing-forecasting/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This three part write up [<a href="/blog/2016/02/16/triple-exponential-smoothing-forecasting-part-ii/">Part II</a>
<a href="/blog/2016/02/17/triple-exponential-smoothing-forecasting-part-iii/">Part III</a>]
is my attempt at a down-to-earth explanation (and Python code) of the
Holt-Winters method for those of us who while hypothetically might be
quite good at math, still try to avoid it at every opportunity. I had
to dive into this subject while tinkering on
<a href="https://github.com/tgres/tgres">tgres</a> (which features a Golang implementation). And
having found it somewhat complex (and yet so brilliantly
simple), figured that it’d be good to share this knowledge, and
in the process, to hopefully solidify it in my head as well.</p>

<p><a href="https://en.wikipedia.org/wiki/Exponential_smoothing#Triple_exponential_smoothing">Triple Exponential Smoothing</a>,
also known as the Holt-Winters method, is one of the many methods or
algorithms that can be used to forecast data points in a series,
provided that the series is “seasonal”, i.e. repetitive over some
period.</p>

<p><img src="/images/hw00.png" /></p>

<h1 id="a-little-history">A little history</h1>

<p>Еxponential smoothing in some form or another dates back to the work
of <a href="https://en.wikipedia.org/wiki/Sim%C3%A9on_Denis_Poisson">Siméon Poisson</a> (1781-1840),
while its application in forecasting appears to have been pioneered over a century later in 1956 by
<a href="https://en.wikipedia.org/wiki/Robert_Goodell_Brown">Robert Brown</a> (1923–2013)
in his publication
<a href="https://industrydocuments.library.ucsf.edu/tobacco/docs/#id=jzlc0130">Exponential Smoothing for Predicting Demand</a>,
(Cambridge, Massachusetts). [Based on the URL it seems Brown was working on forecasting tobacco demand?]</p>

<p>In 1957 an <a href="http://web.mit.edu/">MIT</a> and <a href="http://www.uchicago.edu/">University of Chicago</a>
graduate, professor <a href="https://en.wikipedia.org/wiki/Charles_C._Holt">Charles C Holt</a>
(1921-2010) was working at <a href="http://www.cmu.edu/">CMU</a> (then known as CIT) on forecasting trends in production,
inventories and labor force.
It appears that Holt and Brown worked independently  and knew not of each-other’s work.
Holt published a paper “Forecasting trends
and seasonals by exponentially weighted moving averages” (Office of Naval Research Research
Memorandum No. 52, Carnegie Institute of Technology) describing
double exponential smoothing. Three years later, in 1960, a student of
Holts (?) Peter R. Winters improved the algorithm by adding seasonality and
published
<a href="http://pubsonline.informs.org/doi/abs/10.1287/mnsc.6.3.324">Forecasting sales by exponentially weighted moving averages</a>
(Management Science 6, 324–342), citing Dr. Holt’s 1957 paper as earlier work on the same subject.
This algorithm became known as triple exponential smoothing or the Holt-Winters method,
the latter probably because it was described in a 1960 Prentice-Hall book “Planning Production, Inventories, and Work Force”
by Holt, <a href="https://en.wikipedia.org/wiki/Franco_Modigliani">Modigliani</a>, <a href="https://en.wikipedia.org/wiki/John_Muth">Muth</a>,
<a href="https://en.wikipedia.org/wiki/Herbert_A._Simon">Simon</a>,
<a href="https://www.gsb.stanford.edu/faculty-research/faculty/charles-puis-bonini">Bonini</a> and Winters - good luck finding a copy!</p>

<p>Curiously, I’ve not been able to find any personal information on Peter R. Winters online. If you find anything, please let me
know, I’ll add a reference here.</p>

<p>In 2000 the Holt-Winters method became well known in the <a href="https://en.wikipedia.org/wiki/Internet_service_provider">ISP</a>
circles at the height of the <a href="https://en.wikipedia.org/wiki/Dot-com_bubble">.com boom</a> when Jake D. Brutlag (then of WebTV) published
<a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwiAx9SNoezKAhXCC5oKHZZ4A84QFgghMAA&amp;url=https%3A%2F%2Fwww.usenix.org%2Fevents%2Flisa00%2Ffull_papers%2Fbrutlag%2Fbrutlag.pdf&amp;usg=AFQjCNEg-ynB5Ok0Sf4ATBB77PcGwT4OLw&amp;bvm=bv.113943665,d.bGs">Aberrant Behavior Detection in Time Series for Network Monitoring</a>
(Proceedings of the 14th Systems Administration Conference, LISA
2000). It described how an open source <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a>
implementation [<a href="https://github.com/oetiker/rrdtool-1.x/commit/cafbbce69d9d1d4a1772299d97138b5a81d343f5">link to the actual commit</a>]
of a variant of the Holt-Winters seasonal method, which he contributed as a feature
to the very popular at ISPs <a href="http://oss.oetiker.ch/rrdtool/">RRDTool</a>, could be used to
monitor network traffic.</p>

<p>In 2003, a remarkable 40+ years since the publication of Winters
paper, professor <a href="http://www.sbs.ox.ac.uk/community/people/james-taylor">James W Taylor</a>
of <a href="http://www.ox.ac.uk/">Oxford University</a> extended the
Holt-Winters method to multiple seasonalities (i.e. $n$-th exponential
smoothing) and published <a href="http://users.ox.ac.uk/~mast0315/ExpSmDoubleSeasonal.pdf">Short-term electricity demand forecasting using double seasonal exponential smoothing</a>
(Journal of Operational
Research Society, vol. 54, pp. 799–805). (But we won’t cover Taylors
method here).</p>

<p>In 2011 the RRDTool implementation contributed by Brutlag was
<a href="https://github.com/graphite-project/graphite-web/commit/4e7a0d664ea2153ea65173138ab8f337716e21fa">ported</a>
to <a href="http://graphite.readthedocs.org/en/latest/">Graphite</a> by Matthew Graham thus making it even more popular in the
devops community.</p>

<p>So… how does it work?</p>

<h1 id="forecasting-baby-steps">Forecasting, Baby Steps</h1>

<p>The best way to explain triple exponential smoothing is to gradually
build up to it starting with the simplest forecasting methods. Lest
this text gets too long, we will stop at triple exponential smoothing,
though there are quite a few other methods known.</p>

<p>I used mathematical notation only where I thought it made best sense, sometimes
accompanied by an “English translation”, and where appropriate
supplemented with a bit of <a href="http://www.python.org">Python</a> code.
In Python I refrain from using any non-standard packages, keeping the
examples plain. I chose not to use <a href="https://wiki.python.org/moin/Generators">generators</a>
for clarity. The objective here is to explain
the inner working of the algorithm so that you can implement it
yourself in whatever language you prefer.</p>

<p>I also hope to demonstrate that this is simple enough that you do not
need to resort to <a href="http://www.scipy.org/">SciPy</a> or <a href="https://en.wikipedia.org/wiki/R_%28programming_language%29">whatever</a>
(not that there is anything wrong with that).</p>

<h2 id="but-first-some-terminology">But First, Some Terminology</h2>

<h3 id="series"><em>Series</em></h3>

<p>The main subject here is a <em>series</em>. In the real world we are most
likely to be applying this to a <em>time series</em>, but for this discussion
the time aspect is irrelevant. A series is merely an ordered sequence
of numbers. We might be using words that are chronological in nature
(past, future, yet, already, <em>time</em> even!), but only because it makes it easer to
understand. So forget about time, timestamps, intervals,
<a href="http://www.preposterousuniverse.com/blog/2013/10/18/is-time-real/">time does not exist</a>,
the only property each data point has (other than the value) is its order: first,
next, previous, last, etc.</p>

<p>It is useful to think of a series as a list of two-dimensional $x,y$
coordinates, where $x$ is order (always going up by 1), and $y$ is
value. For this reason in our math formulas we will be sticking to $y$
for value and $x$ for order.</p>

<h3 id="observed-vs-expected"><em>Observed</em> vs <em>Expected</em></h3>

<p>Forecasting is estimating values that we do not yet know based on the
the values we do know. The values we know are referred to as
<em>observed</em> while the values we forecast as <em>expected</em>. The math
convention to denote expected values is with the
<a href="https://en.wikipedia.org/wiki/Circumflex">circumflex</a> a.k.a. “hat”: $\hat{y}$</p>

<p>For example, if we have a series that looks like <code>[1,2,3]</code>, we might
forecast the next value to be 4. Using this terminology, given
observed series <code>[1,2,3]</code> the next expected value ${\hat{y}_4}$ is 4.</p>

<h3 id="method"><em>Method</em></h3>

<p>We may have intuited based on <code>[1,2,3]</code> that in this series each value
is 1 greater than the previous, which in math notation can
be expressed as and $\hat{y}_{x + 1} = y_x + 1$.  This equation, the
result of our intuition, is known as a forecast <em>method</em>.</p>

<p>If our method is correct then the next observed value would indeed be
4, but if <code>[1,2,3]</code> is actually part of a
<a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci sequence</a>, then where we
expected ${\hat{y}_4 = 4}$, we would observe $y_4 = 5$. Note the hatted
${\hat{y}}$ (expected) in the former and $y$ (observed) in the latter expression.</p>

<h3 id="error-sse-and-mse"><em>Error</em>, <em>SSE</em> and <em>MSE</em></h3>

<p>It is perfectly normal to compute expected values where we already
have observed values. Comparing the two lets you compute the <em>error</em>,
which is the <em>difference</em> between observed and expected and is an
indispensable indication of the accuracy of the method.</p>

<p>Since difference can be negative or positive, the common convention is
to use the absolute value or square the error so that the number is always
positive. For a whole series the squared errors are typically summed
resulting in <em><a href="https://en.wikipedia.org/wiki/Residual_sum_of_squares">Sum of Squared Errors</a> (SSE)</em>.
Sometimes you may come across <em><a href="https://en.wikipedia.org/wiki/Residual_sum_of_squares">Mean Squared Error</a>
(MSE)</em> which is simply $\sqrt{SSE}$.</p>

<h2 id="and-now-the-methods-where-the-fun-begins">And Now the Methods (where the fun begins!)</h2>

<p>In the next few examples we are going to be using this tiny series:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">series</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(Feel free to paste it and any of the following code snippets into your Python
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">repl</a>)</p>

<h3 id="naive-method">Naive Method</h3>

<p>This is the most primitive forecasting method. The premise of the
<em>naive</em> method is that the expected point is equal to the last
observed point:</p>

<script type="math/tex; mode=display">
\hat{y}_{x+1} = y_x
</script>

<p>Using this method we would forecast the next point to be 12.</p>

<h3 id="simple-average">Simple Average</h3>

<p>A less primitive method is the <a href="https://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic average</a>
of all the previously observed data points. We take all the values we
know, calculate the average and bet that that’s going to be the next value. Of course it won’t be it exactly,
but it probably will be somewhere in the ballpark, hopefully you can see the reasoning behind this
simplistic approach.</p>

<script type="math/tex; mode=display">
\hat{y}_{x+1} = \dfrac{1}{x}\sum_{i=1}^{x}y_i
</script>

<p>(Okay, this formula is only here because I think the <a href="https://en.wikipedia.org/wiki/Summation">capital Sigma</a>
looks cool. I am sincerely hoping that the average requires no explanation.) In Python:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">series</span><span class="p">))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="c"># Given the above series, the average is:</span>
</span><span class="line"><span class="c"># &gt;&gt;&gt; average(series)</span>
</span><span class="line"><span class="c"># 10.285714285714286</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>As a forecasting method, there are actually situations where it’s spot
on. For example your final school grade may be the average of all the
previous grades.</p>

<h3 id="moving-average">Moving Average</h3>

<p>An improvement over simple average is the average of $n$ last
points. Obviously the thinking here is that only the recent values
matter. Calculation of the moving average involves what is sometimes
called a “sliding window” of size $n$:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># moving average using n last points</span>
</span><span class="line"><span class="k">def</span> <span class="nf">moving_average</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</span><span class="line">    <span class="k">return</span> <span class="n">average</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:])</span>
</span><span class="line">
</span><span class="line"><span class="c"># &gt;&gt;&gt; moving_average(series, 3)</span>
</span><span class="line"><span class="c"># 11.333333333333334</span>
</span><span class="line"><span class="c"># &gt;&gt;&gt; moving_average(series, 4)</span>
</span><span class="line"><span class="c"># 11.75</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>A moving average can actually be quite effective, especially if you
pick the right $n$ for the series. Stock analysts adore it.</p>

<p>Also note that simple average is a variation of a moving average, thus
the two functions above could be re-written as a single recursive one
(just for fun):</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</span><span class="line">    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
</span><span class="line">        <span class="k">return</span> <span class="n">average</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">))</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]))</span><span class="o">/</span><span class="n">n</span>
</span><span class="line">
</span><span class="line"><span class="c"># &gt;&gt;&gt; average(series, 3)</span>
</span><span class="line"><span class="c"># 11.333333333333334</span>
</span><span class="line"><span class="c"># &gt;&gt;&gt; average(series)</span>
</span><span class="line"><span class="c"># 10.285714285714286</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="weighted-moving-average">Weighted Moving Average</h3>

<p>A <em>weighted</em> moving average is a moving average where within the
sliding window values are given different weights, typically so that
more recent points matter more.</p>

<p>Instead of selecting a window size, it requires a list of weights
(which should add up to 1). For example if we picked <code>[0.1,
0.2, 0.3, 0.4]</code> as weights, we would be giving 10%, 20%, 30% and 40%
to the last 4 points respectively. In Python:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># weighted average, weights is a list of weights</span>
</span><span class="line"><span class="k">def</span> <span class="nf">weighted_average</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
</span><span class="line">    <span class="n">result</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class="line">    <span class="n">weights</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
</span><span class="line">    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)):</span>
</span><span class="line">        <span class="n">result</span> <span class="o">+=</span> <span class="n">series</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</span><span class="line">    <span class="k">return</span> <span class="n">result</span>
</span><span class="line">
</span><span class="line"><span class="c"># &gt;&gt;&gt; weights = [0.1, 0.2, 0.3, 0.4]</span>
</span><span class="line"><span class="c"># &gt;&gt;&gt; weighted_average(series, weights)</span>
</span><span class="line"><span class="c"># 11.5</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Weighted moving average is fundamental to what follows, please take a
moment to understand it, give it a think before reading on.</p>

<p>I would also like to stretch the importance of the weights adding up
to 1. To demonstrate why, let’s say we pick weights <code>[0.9, 0.8, 0.7,
0.6]</code> (which add up to 3.0). Watch what happens:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&gt;&gt;&gt; weighted_average(series, [0.9, 0.8, 0.7, 0.6])
</span><span class="line">&gt;&gt;&gt; 35.5  # &lt;--- this is clearly bogus</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="picture-time">Picture time!</h3>

<p>Here is a picture that demonstrates our tiny series and all of the above
forecasts (except for naive).</p>

<p><img src="/images/hw01.png" /></p>

<p>It’s important to understand that which of the above methods is better
very much depends on the nature of the series. The order in which I
presented them was from simple to complex, but “more complex” doesn’t
necessarily mean “better”.</p>

<h3 id="single-exponential-smoothing">Single Exponential Smoothing</h3>

<p>Here is where things get interesting. Imagine a weighted average where
we consider <em>all</em> of the data points, while assigning exponentially
smaller weights as we go back in time. For example if we started with
0.9, our weights would be (going back in time):</p>

<script type="math/tex; mode=display">
0.9^1, 0.9^2, 0.9^3, 0.9^4, 0.9^5, 0.9^6... \\
\mbox{or: } 0.9, 0.81, 0.729, 0.6561, 0.59049, 0.531441, ...
</script>

<p>…eventually approaching the big old zero. In some way this is very
similar to the weighted average above, only the weights are dictated
by math, decaying uniformly. The smaller the starting weight, the
faster it approaches zero.</p>

<p>Only… there is a problem: weights do not add up to 1. The sum of
the first 3 numbers alone is already 2.439! (Exercise for the reader: what number
does the sum of the weights approach and why?)</p>

<p>What earned Poisson, Holts or Roberts a permanent place in the history
of Mathematics is solving this with a succinct and elegant formula:</p>

<script type="math/tex; mode=display">
\hat{y}_x = \alpha \cdot y_x + (1-\alpha) \cdot \hat{y}_{x-1} \\
</script>

<p>If you stare at it just long enough, you will see that the expected
value $\hat{y}_x$ is the sum of two products: $\alpha \cdot y_x$ and
$(1-\alpha) \cdot \hat{y}_{x-1}$. You can think of $\alpha$ (alpha)
as a sort of a starting weight 0.9 in the above (problematic)
example. It is called the <em>smoothing factor</em> or <em>smoothing
coefficient</em> (depending on who wrote your text book).</p>

<p>So essentially we’ve got a weighted moving average with two weights:
$\alpha$ and $1-\alpha$.  The sum of $\alpha$ and $1-\alpha$ is 1, so
all is well.</p>

<p>Now let’s zoom in on the right side of the sum. Cleverly, $1-\alpha$
is multiplied by the <em>previous</em> expected value
$\hat{y}_{x-1}$. Which, if you think about it, is the result of the
same formula, which makes the expression recursive (and programmers
love recursion), and if you were to write it all out on paper you would
quickly see that $(1-\alpha)$ is multiplied by itself again and again
all the way to beginning of the series, if there is one, infinitely
otherwise. And this is why this method is called
<em>exponential</em>.</p>

<p>Another important thing about $\alpha$ is that its value dictates how
much weight we give the most recent observed value versus the last
expected. It’s a kind of a lever that gives more weight to the left
side when it’s higher (closer to 1) or the right side when it’s lower
(closer to 0).</p>

<p>Perhaps $\alpha$ would be better referred to as <em>memory decay rate</em>: the
higher the $\alpha$, the faster the method “forgets”.</p>

<h4 id="why-is-it-called-smoothing">Why is it called “smoothing”?</h4>

<p>To the best of my understanding this simply refers to the effect these
methods have on a graph if you were to plot the values: jagged lines
become smoother.  Moving average also has the same effect, so it
deserves the right to be called smoothing just as well.</p>

<h4 id="implementation">Implementation</h4>

<p>There is an aspect of this method that programmers would appreciate
that is of no concern to mathematicians: it’s simple and efficient to
implement. Here is some Python. Unlike the previous examples, this
function returns expected values for the whole series, not just one
point.</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="c"># given a series and alpha, return series of smoothed points</span>
</span><span class="line"><span class="k">def</span> <span class="nf">exponential_smoothing</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
</span><span class="line">    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c"># first value is same as series</span>
</span><span class="line">    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)):</span>
</span><span class="line">        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">series</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">result</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span><span class="line">    <span class="k">return</span> <span class="n">result</span>
</span><span class="line">
</span><span class="line"><span class="c"># &gt;&gt;&gt; exponential_smoothing(series, 0.1)</span>
</span><span class="line"><span class="c"># [3, 3.7, 4.53, 5.377, 6.0393, 6.43537, 6.991833]</span>
</span><span class="line"><span class="c"># &gt;&gt;&gt; exponential_smoothing(series, 0.9)</span>
</span><span class="line"><span class="c"># [3, 9.3, 11.73, 12.873000000000001, 12.0873, 10.20873, 11.820873]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The figure below shows exponentially smoothed version of our series
with $\alpha$ of 0.9 (red) and $\alpha$ of 0.1 (orange).</p>

<p><img src="/images/hw02.png" /></p>

<p>Looking at the above picture it is apparent that the $\alpha$ value of 0.9
follows the observed values much closer than 0.1. This isn’t going to
be true for any series, each series has its best $\alpha$ (or
several). The process of finding the best $\alpha$ is referred to as
<em>fitting</em> and we will discuss it later separately.</p>

<h2 id="quick-review">Quick Review</h2>

<p>We’ve learned some history, basic terminology (series and how it knows
no time, method, error SSE, MSE and fitting). And we’ve learned some
basic forecasting methods: naive, simple average, moving average,
weighted moving average and, finally, single exponential smoothing.</p>

<p>One very important characteristic of all of the above methods is that
remarkably, they can only forecast a <em>single</em> point. That’s correct,
just one.</p>

<p>In <a href="/blog/2016/02/16/triple-exponential-smoothing-forecasting-part-ii/">Part II</a> we will focus on methods that can forecast more than
one point.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/23/storing-time-series-in-postgresql-efficiently/">Storing Time Series in PostgreSQL Efficiently</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-23T22:01:00-04:00" pubdate data-updated="true">Sep 23<span>rd</span>, 2015</time>
        
         | <a href="/blog/2015/09/23/storing-time-series-in-postgresql-efficiently/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>With the latest advances in PostgreSQL (and other db’s), a relational
database begins to look like a very viable TS storage platform. In
this write up I attempt to show how to store TS in PostgreSQL.</p>

<p>A TS is a series of [timestamp, measurement] pairs, where measurement
is typically a floating point number. These pairs (aka “data points”)
usually arrive at a high and steady rate. As time goes on, detailed
data usually becomes less interesting and is often consolidated into
larger time intervals until ultimately it is expired.</p>

<h2 id="the-obvious-approach">The obvious approach</h2>

<p>The “naive” approach is a three-column table, like so:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sql"><span class="line"> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">ts</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INT</span><span class="p">,</span> <span class="n">time</span> <span class="n">TIMESTAMPTZ</span><span class="p">,</span> <span class="n">value</span> <span class="nb">REAL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(Let’s gloss over some details such as an index on the time column and
choice of data type for time and value as it’s not relevant to this
discussion.)</p>

<p>One problem with this is the inefficiency of appending data. An insert
requires a look up of the new id, locking and (usually) blocks until
the data is synced to disk. Given the TS’s “firehose” nature, the
database can quite quickly get overwhelmed.</p>

<p>This approach also does not address consolidation and eventual
expiration of older data points.</p>

<h2 id="round-robin-database">Round-robin database</h2>

<p>A better alternative is something called a <em>round-robin database</em>.  An
RRD is a circular structure with a separately stored pointer denoting
the last element and its timestamp.</p>

<p>A everyday life example of an RRD is a week. Imagine a structure of 7
slots, one for each day of the week. If you know today’s date and day
of the week, you can easily infer the date for each slot. For example
if today is Tuesday, April 1, 2008, then the Monday slot refers to
March 31st, Sunday to March 30th and (most notably) Wednesday to March
26.</p>

<p>Here’s what a 7-day RRD of average temperature might look as of
Tuesday, April 1:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="sql"><span class="line"><span class="n">Week</span> <span class="k">day</span><span class="p">:</span> <span class="n">Sun</span>  <span class="n">Mon</span>  <span class="n">Tue</span>  <span class="n">Wed</span>  <span class="n">Thu</span>  <span class="n">Fri</span>  <span class="n">Sat</span>
</span><span class="line"><span class="nb">Date</span><span class="p">:</span>     <span class="mi">3</span><span class="o">/</span><span class="mi">30</span> <span class="mi">3</span><span class="o">/</span><span class="mi">31</span> <span class="mi">4</span><span class="o">/</span><span class="mi">1</span>  <span class="mi">3</span><span class="o">/</span><span class="mi">26</span> <span class="mi">3</span><span class="o">/</span><span class="mi">27</span> <span class="mi">3</span><span class="o">/</span><span class="mi">28</span> <span class="mi">3</span><span class="o">/</span><span class="mi">29</span>
</span><span class="line"><span class="n">Temp</span> <span class="n">F</span><span class="p">:</span>   <span class="mi">79</span>   <span class="mi">82</span>   <span class="mi">90</span>   <span class="mi">69</span>   <span class="mi">75</span>   <span class="mi">80</span>   <span class="mi">81</span>
</span><span class="line">                    <span class="o">^</span>
</span><span class="line">                    <span class="k">last</span> <span class="n">entry</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Come Wednesday, April 2nd, our RRD now loooks like this:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="sql"><span class="line"><span class="n">Week</span> <span class="k">day</span><span class="p">:</span> <span class="n">Sun</span>  <span class="n">Mon</span>  <span class="n">Tue</span>  <span class="n">Wed</span>  <span class="n">Thu</span>  <span class="n">Fri</span>  <span class="n">Sat</span>
</span><span class="line"><span class="nb">Date</span><span class="p">:</span>     <span class="mi">3</span><span class="o">/</span><span class="mi">30</span> <span class="mi">3</span><span class="o">/</span><span class="mi">31</span> <span class="mi">4</span><span class="o">/</span><span class="mi">1</span>  <span class="mi">4</span><span class="o">/</span><span class="mi">2</span>  <span class="mi">3</span><span class="o">/</span><span class="mi">27</span> <span class="mi">3</span><span class="o">/</span><span class="mi">28</span> <span class="mi">3</span><span class="o">/</span><span class="mi">29</span>
</span><span class="line"><span class="n">Temp</span> <span class="n">F</span><span class="p">:</span>   <span class="mi">79</span>   <span class="mi">82</span>   <span class="mi">90</span>   <span class="mi">92</span>   <span class="mi">75</span>   <span class="mi">80</span>   <span class="mi">81</span>
</span><span class="line">                         <span class="o">^</span>
</span><span class="line">                         <span class="k">last</span> <span class="n">entry</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Note how little has changed, and that the update required no
allocation of space: all we did to record 92F on Wednesday is
overwrite one value. Even more remarkably, the previous value
automatically “expired” when we overwrote it, thus solving the
eventual expiration problem without any additional operations.</p>

<p>RRD’s are also very space-efficient. In the above example we specified
the date of every slot for clarity. In an actual implementation only
the date of the last slot needs to be stored, thus the RRD can be kept
as a sequence of 7 numbers plus the position of the last entry and
it’s timestamp. In Python syntax it’d look like this:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="p">[[</span><span class="mi">79</span><span class="p">,</span><span class="mi">82</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">92</span><span class="p">,</span><span class="mi">75</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">81</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1207022400</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="round-robin-in-postgresql">Round-robin in PostgreSQL</h2>

<p>Here is a naive approach to having a round-robin table. Carrying on
with our 7 day RRD example, it might look like this:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">week_day</span> <span class="o">|</span> <span class="n">temp_f</span>
</span><span class="line"><span class="o">---------+--------</span>
</span><span class="line">     <span class="mi">1</span>   <span class="o">|</span>   <span class="mi">79</span>
</span><span class="line">     <span class="mi">2</span>   <span class="o">|</span>   <span class="mi">82</span>
</span><span class="line">     <span class="mi">3</span>   <span class="o">|</span>   <span class="mi">90</span>
</span><span class="line">     <span class="mi">4</span>   <span class="o">|</span>   <span class="mi">69</span>
</span><span class="line">     <span class="mi">5</span>   <span class="o">|</span>   <span class="mi">75</span>
</span><span class="line">     <span class="mi">6</span>   <span class="o">|</span>   <span class="mi">80</span>
</span><span class="line">     <span class="mi">7</span>   <span class="o">|</span>   <span class="mi">81</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Somewhere separately we’d also need to record that the last entry is
week_day 3 (Tuesday) and it’s 2008-04-01. Come April 2, we could
record the temperature using:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sql"><span class="line"><span class="k">UPDATE</span> <span class="n">series</span> <span class="k">SET</span> <span class="n">temp_f</span> <span class="o">=</span> <span class="mi">92</span> <span class="k">WHERE</span> <span class="n">week_day</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This might be okay for a 7-slot RRD, but a more typical TS might have
a slot per minute going back 90 days, which would require 129600
rows. For recording data points one at a time it might be fast enough,
but to copy the whole RRD would require 129600 UPDATE statements which
is not very efficient.</p>

<p>This is where using PostgrSQL <em>arrays</em> become very useful.</p>

<h2 id="using-postgresql-arrays">Using PostgreSQL arrays</h2>

<p>An array would allow us to store the whole series in a single
row. Sticking with the 7-day RRD example, our table would be created
as follows:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="sql"><span class="line"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">ts</span> <span class="p">(</span><span class="n">dp</span> <span class="n">DOUBLE</span> <span class="k">PRECISION</span><span class="p">[]</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;{}&#39;</span><span class="p">,</span>
</span><span class="line">                 <span class="n">last_date</span> <span class="nb">DATE</span><span class="p">,</span>
</span><span class="line">                 <span class="n">pos</span> <span class="nb">INT</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(Nevemind that there is no id column for now)</p>

<p>We could populate the whole RRD in a single statement:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sql"><span class="line"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">ts</span> <span class="k">VALUES</span><span class="p">(</span><span class="s1">&#39;{79,82,90,69,75,80,81}&#39;</span><span class="p">,</span> <span class="s1">&#39;2008-08-01&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>…or record 92F for Wednesday as so:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sql"><span class="line"><span class="k">UPDATE</span> <span class="n">ts</span> <span class="k">SET</span> <span class="n">dp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">92</span><span class="p">,</span> <span class="n">last_date</span> <span class="o">=</span> <span class="s1">&#39;2008-04-02&#39;</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(In PostgreSQL arrays are 1-based, not 0-based like in most
programming languages)</p>

<h2 id="but-it-could-be-even-more-efficient">But it could be even more efficient</h2>

<p>Under the hood, PostgreSQL data is stored in pages of 8K. It would
make sense to keep chunks in which our RRD is written to disk in line
with page size, or at least smaller than one page. (PostgreSQL provides
configuration parameters for how much of a page is used, etc, but this
is way beyond the scope of this article).</p>

<p>Having the series split into chunks also paves the way for some kind
of a caching layer, we could have a server which waits for one row
worth of data points to accumulate, then flushes then all at once.</p>

<p>For simplicity, let’s take the above example and expand the RRD to 4
weeks, while keeping 1 week per row. In our table definition we need
provide a way for keeping the order of every row of the TS with a
column named n, and while we’re at it, we might as well introduce a
notion of an id, so as to be able to store multiple TS in the same
table.</p>

<p>Let’s start with two tables, one called rrd where we would store the
last position and date, and another called ts which would store the
actual data.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="sql"><span class="line"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">rrd</span> <span class="p">(</span>
</span><span class="line">  <span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
</span><span class="line">  <span class="n">last_date</span> <span class="nb">DATE</span><span class="p">,</span>
</span><span class="line">  <span class="n">last_pos</span> <span class="nb">INT</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">ts</span> <span class="p">(</span>
</span><span class="line">  <span class="n">rrd_id</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
</span><span class="line">  <span class="n">n</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
</span><span class="line">  <span class="n">dp</span> <span class="n">DOUBLE</span> <span class="k">PRECISION</span><span class="p">[]</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;{}&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We could then populate the TS with fictitious data like so:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="sql"><span class="line"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">rrd</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">last_date</span><span class="p">,</span> <span class="n">last_pos</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2008-04-01&#39;</span><span class="p">,</span> <span class="mi">24</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">ts</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;{64,67,70,71,72,69,67}&#39;</span><span class="p">);</span>
</span><span class="line"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">ts</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;{65,60,58,59,62,68,70}&#39;</span><span class="p">);</span>
</span><span class="line"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">ts</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;{71,72,77,70,71,73,75}&#39;</span><span class="p">);</span>
</span><span class="line"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">ts</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;{79,82,90,69,75,80,81}&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>To update the data for April 2, we would:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="sql"><span class="line"><span class="k">UPDATE</span> <span class="n">ts</span> <span class="k">SET</span> <span class="n">dp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">92</span> <span class="k">WHERE</span> <span class="n">rrd_id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line"><span class="k">UPDATE</span> <span class="n">rrd</span> <span class="k">SET</span> <span class="n">last_date</span> <span class="o">=</span> <span class="s1">&#39;2008-04-02&#39;</span><span class="p">,</span> <span class="n">last_pos</span> <span class="o">=</span> <span class="mi">25</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The last_pos of 25 is n * 7 + 1 (since arrays are 1-based).</p>

<p>This article omits a lot of detail such as having resolution finer
than one day, but it does describe the general idea. For an actual
implementation of this you might want to check out a project I’ve been
working on: <a href="https://github.com/grisha/timeriver">timeriver</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/04/recording-time-series/">Time Series Accuracy - Graphite vs RRDTool</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-05-04T17:40:00-04:00" pubdate data-updated="true">May 4<span>th</span>, 2015</time>
        
         | <a href="/blog/2015/05/04/recording-time-series/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Back in my ISP days, we used data stored in RRDs to bill our
customers. I wouldn’t try this with Graphite. In this write up I try
to explain why it is so by comparing the method of recording time series
used by
<a href="http://graphite.readthedocs.org/en/latest/overview.html">Graphite</a>,
with the one used by <a href="https://oss.oetiker.ch/rrdtool/">RRDTool</a>.</p>

<p>Graphite uses
<a href="http://graphite.wikidot.com/whisper">Whisper</a> to store data, which in
the FAQ is portrayed as a <a href="http://graphite.wikidot.com/whisper#toc1">better alternative</a> to RRDTool, but
this is potentially misleading, because the flexibility afforded by the
design of Whisper comes at the price of inaccuracy.</p>

<p>A time series is most often described as a sequence of <code>(time, value)</code>
tuples [1]. The most naive method of recording a time series is to
store timestamps as is. Since the data points might arrive at
arbitrary and inexact intervals, to correlate the series with a
particular point in time might be tricky. If data points are arriving
somewhere in between one minute bounaries (as they always naturally
would), to answer the question of what happened during a particular
minute would require specifying a range, which is not as clean as
being able to specify a precise value. To join two series on a range
is even more problematic.</p>

<p>One way to improve upon this is to divide time into equal intervals
and assign data points to the intervals. We could then use the
beginning of the interval instead of the actual data point timestamp,
thereby giving us more uniformity. For example, if our interval size
is 10 seconds (I may sometimes refer to it as the <em>step</em>), we could
divide the entire timeline starting from the
<a href="http://en.wikipedia.org/wiki/Unix_time">beginning of the epoch</a>
and until the end of
universe into 10 second slots. Since the first slot begins at 0, any
10-second-step time series will have slots starting at the exact same
times. Now correlation across series or other time values becomes much
easier.</p>

<p>Calculating the slot is trivially easy: <code>time - time % step</code> (<code>%</code> being
the <a href="https://docs.python.org/3.4/reference/expressions.html#index-51">modulo operator</a>).
There is, however, a subtle complexity lurking when it comes to
storing the datapoint with the adjusted (or <em>aligned</em>) timestamp.
Graphite simply changes the timestamp of the data point to the
aligned one. If multiple data points arrive in the same
step, then the last one “wins”.</p>

<p>On the surface there is little wrong with Graphite’s approach. In fact,
under right circumstances, there is absolutely nothing wrong with
it. Consider the following example:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Graphite, 10 second step.
</span><span class="line">
</span><span class="line">Actual Time   Aligned Time
</span><span class="line">1430701282    1430701280     50  &lt;-- This data point is lost
</span><span class="line">1430701288    1430701280     10
</span><span class="line">1430701293    1430701290     30
</span><span class="line">1430701301    1430701300     30</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Let’s pretend those values are some system metric like the number of
files open. The consequence of the 50 being dropped is that we will
never know it existed, but towards the end of the 10 second interval
it went down to 10, which is still a true fact. If we really wanted to
know about the variations within a 10 second interval, we should have
chosen a smaller step, e.g. 1 second. By deciding that the step is
going to be 10 seconds, we thus declared that <em>variations within a
smaller period are of no interest</em> to us, and from this perspective,
Graphite <em>is correct</em>.</p>

<p>But what if those numbers are the price of a stock: there may be
hundreds of thousand of trades within a 10 second interval, yet we do
not want to (or cannot, for technical reasons) record every single one
of them? In this scenario having the last value override all previous
ones doesn’t exactly seem correct.</p>

<p>Enter RRDTool which uses a different method. RRDTool keeps track of
the last timestamp and calculates a weight for every incoming
data point based on time since last update or beginning of the step and
the step length. Here is what the same sequence of points looks like
in RRDTool. The lines marked with a <code>*</code> are not actual data points,
but are the last value for the preceding step, it’s used for
computing the value for the remainder of the step after a new one has
begun.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">RRDTool, 10 second step.
</span><span class="line">
</span><span class="line">  Time          Value       Time since  Weight  Adjusted   Recorded
</span><span class="line">                            last                value      value
</span><span class="line">  1430701270    0           N/A
</span><span class="line">* 1430701280    50         10s          1       50* 1= 50
</span><span class="line">                                                           50
</span><span class="line">  1430701282    50          2s          .2      50*.2= 10
</span><span class="line">  1430701288    10          6s          .6      10*.6= 6
</span><span class="line">* 1430701290    30          2s          .2      30*.2= 6
</span><span class="line">                                                           10+6+6= 22
</span><span class="line">  1430701293    30          3s          .3      30*.3= 9
</span><span class="line">* 1430701300    30          7s          .7      30*.7= 21
</span><span class="line">                                                           9+21=   30
</span><span class="line">  1430701301    30   # this data point is incomplete</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Note, by the way, that the Whisper FAQ says that “RRD will store your
updates in a temporary workspace area and after the minute has passed,
aggregate them and store them in the archive”, which to me sounds like
there is some sort of a temporary storage area holding all the unsaved
updates. In fact, to be able to compute the weighted average, RRD only
needs to store the time of the last update and the current sum, i.e.
exactly just two variables, regardless of the number of updates in a
single step. This is evident from the above figure.</p>

<p>So to compare the results of the two tools:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Time Slot     Graphite    RRDTool
</span><span class="line">1430701270       N/A        50
</span><span class="line">1430701280       10         22
</span><span class="line">1430701290       30         30
</span><span class="line">1430701300       N/A        N/A
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Before you say “so what, I don’t really understand the difference”,
let’s pretend that those numbers were actually the rate of sale of
trinkets from our website (per second). Here is a horizontal ascii-art
rendition of our timeline, 0 is 1430701270.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">0         10        20        30    time (seconds)
</span><span class="line">+.........+.........+.........+.....
</span><span class="line">|           |     |    |       |
</span><span class="line">0           50    10   30      30   data points</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>At 12 seconds we recorded selling 50 trinkets per second. Assuming we
started selling at the beginning of our timeline, i.e. 12 seconds
earlier, we can state that during the first step we sold exactly 500
trinkets. Then 2 seconds into the second step we sold another 100
(we’re still selling at 50/s). Then for the next 6 seconds we were
selling at 10/s, thus another 60 trinkets, and for the last 2 seconds
of the slot we sold another 60 at 30/s. In the third step we were
selling steadily at 30/s, thus exactly 300 were sold.</p>

<p>Comparing RRDTool and Graphite side-by-side, the stories are quite different:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Trinkets per second and sold:
</span><span class="line">   Time Slot     Graphite Trinkets     RRDTool Trinkets
</span><span class="line">1. 1430701270      N/A      N/A          50      500
</span><span class="line">2. 1430701280       10      100          22      220 (100+60+60)
</span><span class="line">3. 1430701290       30      300          30      300
</span><span class="line">4. 1430701300       30      N/A          N/A     N/A
</span><span class="line">                          -----                -----
</span><span class="line">   TOTAL SOLD:              400                 1020
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Two important observations here:</p>

<ol>
  <li>The totals are vastly different.</li>
  <li>The rate recorded by RRDTool for the second slot (22/s), yields
<em>exactly</em> the number of trinkets sold during that period: 220.</li>
</ol>

<p>Last, but hardly the least, consider what happens when we consolidate
data points into larger intervals by averaging the values. Let’s say
20 seconds, twice our step. If we consolidate the second and the third
steps, we would get:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Graphite:  average(10,30) = 20  =&gt; 400 trinkets in 20 seconds
</span><span class="line">RRDTool:   average(22,30) = 26  =&gt; 520 trinkets in 20 seconds</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Since the Graphite numbers were off to begin with, we have no reason
to trust the 400 trinkets number. But using the RRDTool data, the new
number happens to still be 100% accurate even after the data points
have been consolidated. This is a very useful property of <em>rates</em> in
time series. It also explains why RRDTool does not permit updating
data prior to the last update: RRD is <em>always accurate</em>.</p>

<p>As an exercise, try seeing it for yourself: pretent the value of 10 in
the second step never arrived, which should make the final value of
the second slot 34. If the 10 arrived some time later, averaging it in
will not give you the correct 22.</p>

<p>Whisper allows past updates, but is quasi-accurate to begin with - I’m
not sure I understand which is better - <em>inaccurate</em> data with a data
point missing, or the <em>whole inaccurate</em> data. RRD could accomplish
the same thing by adding some <code>--inaccurate</code> flag, though it would
seem like more of a bug than a feature to me.</p>

<p>If you’re interested in learning more about this, I recommend reading
the documentation for
<a href="http://oss.oetiker.ch/rrdtool/doc/rrdcreate.en.html">rrdtool create</a>, in
particular the “It’s always a Rate” section, as well as
<a href="http://www.vandenbogaerdt.nl/rrdtool/process.php">this post</a>
by Alex van den Bogaerdt.</p>

<p>P.S. After this post was written, someone suggested that instead of
storing a rate, we coud store a <em>count delta</em>. In other words, instead
of recording that we’re selling 10 trinkets per second for the past 6
seconds, we would store the total count of trinkets sold, i.e. 60. At
first this seems like the solution to being able to update historical
data accurately: if later we found out that we sold another 75
trinkets in the second time slot, we could just add it to the total
and all would be well and most importantly <em>accurate</em>.</p>

<p>Here is the problem with this approach: note that in the previous
sentence I had to specify that the additional trinkets were sold <em>in
the second time slot</em>, a small, but crucial detail. If time series
data point is a timestamp and a value, then there isn’t even a way to
relay this information in a single data point - we’d need two
timestamps. On the other hand if every data point arrived with two
timestamps, i.e. as a duration, then which to store, rate or count,
becomes a moot point, we can infer one from the other.</p>

<p>So perhaps another way of explaining the historical update problem is
that it <em>is</em> possible, but the datapoint must specify a <em>time
interval</em>. This is something that neither RRDTool or Graphite
currently support, even though it’d be a very useful feature in my
opinion.</p>

<p>[1] Perhaps the biggest misconception about time series is that it is
a series of data points. What time series represent is <em>continuous</em>
rather than <em>descrete</em>, i.e. it’s the line that connects the points
that matters, not the specific points themselves, they are just
samples at semi-random intervals that help define the line. And as we
know, a line cannot be defined by a single point.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/28/on-time-series/">On Time Series</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-28T15:40:00-04:00" pubdate data-updated="true">Mar 28<span>th</span>, 2015</time>
        
         | <a href="/blog/2015/03/28/on-time-series/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="is-it-even-a-thing">Is it even a thing?</h2>

<p>Time Series is on its way to becoming a buzzword in the Information
Technology circles. This has to do with the looming Internet of Things
which shall cause the Great Reversal of Internet whereby upstream flow
of data produced by said Things is expected to exceed the downstream
flow. Much of this data is expected to be of the Time Series kind.</p>

<p>This, of course, is a money-making opportunity of the Big Data
proportions all over again, and I predict we’re going to see a lot of
Time Series support of various shapes and forms appearing in all
manners of (mostly commercial) software.</p>

<p>But is there really such a thing as the problem specifically inherent
to Time Series data which warrants a specialized solution? I’ve been
pondering this for some time now, and I am still undecided. This
here is my attempt at arguing that TS is <em>not</em> a special problem and
that it can be done by using a database like PostgreSQL.</p>

<h2 id="influx-of-data-and-write-speeds">Influx of data and write speeds</h2>

<p>One frequently cited issue with time series data is that it arrives in
large volumes at a steady pace which renders buffered writes
useless. The number of incoming data streams can also be large
typically causing a disk seek per stream and further complicating the
write situation. TS data also has a property where often more data is
written than read because it’s possible for a datapoint to be
collected and examined only once, if ever. In short, TS is very
write-heavy.</p>

<p>But is this unique? For example logs have almost identical
properties. The real question here is whether our tried and true
databases such as PostgreSQL are ill-equipped to deal with large
volumes of incoming data requiring an alternative solution.</p>

<p>When considering incoming data I am tempted to imagine every US
household sending it, which, of course, would require massive
infrastructure. But this (unrealistic) scenario is not a TS data
problem, it’s one of scale, the same one from which the Hadoops and
Cassandras of this world were born. What is really happening here is
that TS happens to be yet another thing that requires the difficult to
deal with “big data” infrastructure and reiterates the need for an
easy-to-setup horizontally scalable database (which PostgreSQL isn’t).</p>

<h2 id="the-backfill-problem">The backfill problem</h2>

<p>This is the problem of having to import vast amounts of historical
data. For example OpenTSDB goes to great lengths to optimize
back-filling by structuring it in specific ways and storing compressed
blobs of data.</p>

<p>But just like the write problem, it’s not unique to TS. It
is another problem that is becoming more and more pertinent as our
backlogs of data going back to when we stopped using paper keep
growing and growing.</p>

<h2 id="downsampling">Downsampling</h2>

<p>Very often TS data is used to generate charts. This is an artifact of
the human brain being spectacularly good at interpreting a visual
representation of a relationship between streams of numbers while
nearly incapable of making sense of data in tabular form. When
plotting, no matter how much data is being examined, the end result is
limited to however many pixels are available on the display. Even
plotting aside, most any use of time series data is in an aggregated
form.</p>

<p>The process of consolidating datapoints into a smaller number (e.g.
the pixel width of the chart), sometimes called <em>downsampling</em>, involves
aggregation around a particular time interval or simply picking every
Nth datapoint.</p>

<p>As an aside, selecting every Nth row of a table is an interesting SQL
challenge, in PostgreSQL it looks like this (for every 100th row):</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> SELECT time, data FROM
</span><span class="line">   (SELECT *, row_number() OVER (ORDER BY time) as n FROM data_points) dp
</span><span class="line">      WHERE dp.n % 100 = 0 ORDER BY time</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Aggregation over a time interval similar to how InfluxDB does it with
the <code>GROUP BY time(1d)</code> syntax can be easily achieved via the
<code>date_trunc('day', time)</code>.</p>

<p>Another aspect of downsampling is that since TS data is immutable,
there is no need to repeatedly recompute the consolidated version. It
makes more sense to downsample immediately upon the receipt of the
data and to store it permanently in this form. RRDTool’s Round-Robin
database is based entirely on this notion. InfluxDB’s continuous
queries is another way persistent downsampling is addressed.</p>

<p>Again, there is nothing TS-specific here. Storing data in summary form
is quite common in the data analytics world and a “continuous query”
is easily implemented via a trigger.</p>

<h2 id="derivatives">Derivatives</h2>

<p>Sometimes the data from various devices exists in the form of a
counter, which requires the database to derive a rate by comparing
with a previous datapoint. An example of this is number of bytes sent
over a network interface. Only the rate of change of this value is
relevant, not the number itself. The rate of change is the difference
with the previous value divided over the time interval passed.</p>

<p>Referring to a previous row is also a bit tricky but perfectly doable
in SQL. It can accomplished by using windowing functions such as
<code>lag()</code>.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">SELECT time,
</span><span class="line">  (bytes - lag(bytes, 1) OVER w) / extract(epoch from (time - lag(time, 1) OVER w))::numeric
</span><span class="line">    AS bytes_per_sec
</span><span class="line">  FROM data_points
</span><span class="line">  WINDOW w AS (ORDER BY time)
</span><span class="line">  ORDER BY time</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="expiration">Expiration</h2>

<p>It is useful to downsample data to a less granular form as it ages,
aggregating over an ever larger period of time and possibly purging
records eventually. For example we might want to store minutely data
for a week, hourly for 3 months, daily for 3 years and drop all data
beyond 3 years.</p>

<p>Databases do not expire rows “natively” like Cassandra or Redis, but it
shouldn’t be too hard to accomplish via some sort of a periodic cron
job or possibly even just triggers.</p>

<h2 id="heartbeat-and-interval-filling">Heartbeat and Interval Filling</h2>

<p>It is possible for a time series stream to pause, and this can be
interpreted in different ways: we can attempt to fill in missing data,
or treat it as unknown. More likely we’d want to start treating it as
unknown after some period of silence. RRDTool addresses this by
introducing the notion of a <em>heartbeat</em> and the number of missed beats
before data is treated as unknown.</p>

<p>Regardless of whether the value is unknown, it is useful to be able to
fill in a gap (missing rows) in data. In PostgreSQL this can be
accomplished by a join with a result set from the <code>generate_series()</code>
function.</p>

<h2 id="data-seclusion">Data Seclusion</h2>

<p>With many specialized Time Series tools the TS data ends up being
secluded in a separate system not easily accessible from the rest of
the business data. You cannot join your customer records with data in
RRDTool or Graphite or InfluxDB, etc.</p>

<h2 id="conclusion">Conclusion</h2>

<p>If there is a problem with using PosgreSQL or some other database for
Time Series data, it is mainly that of having to use advanced SQL
syntax and possibly requiring some cookie-cutter method for managing
Time Series, especially when it is a large number or series and high
volume.</p>

<p>There is also complexity in horizontally scaling a relational database
because it involves setting up replication, sharding, methods for
recovery from failure and balancing the data. But these are not
TS-specific problems, they are scaling problems.</p>

<p>Having written this up, I’m inclined to think that perhaps there is
no need for a specialized “Time Series Database”, instead it can be
accomplished by an application which uses a database for storage and
abstracts the users from the complexities of SQL and potentially even
scaling, while still allowing for direct access to the data via the
rich set of tools that a database like PostgreSQL provides.</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/20/influxdb-data/">How InfluxDB Stores Data</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-20T15:52:00-04:00" pubdate data-updated="true">Mar 20<span>th</span>, 2015</time>
        
         | <a href="/blog/2015/03/20/influxdb-data/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>A nice, reliable, horizontally scalable database that is designed
specifically to tackle the problem of Time Series data (and does not
require you to stand up a Hadoop cluster) is very much missing from the
Open Source Universe right now.</p>

<p><a href="https://github.com/influxdb/influxdb">InfluxDB</a> might be able to fill this gap, it certainly aims to.</p>

<p>I was curious about how it structures and stores data and since there
wasn’t much documentation on the subject and I ended up just reading
the code, I figured I’d write this up. I only looked at the new
(currently 0.9.0 in RC stage) version, the previous versions are
significantly different.</p>

<p>First of all, InfluxDB is distributed. You can run one node, or a
bunch, it seems like a more typical number may be 3 or 5. The nodes
use <a href="https://github.com/goraft/raft">Raft</a> to establish consensus and maintain data consistency.</p>

<p>InfluxDB feels a little like a relational database in some aspects
(e.g. it has a SQL-like query language) but not in others.</p>

<p>The top level container is a <em>database</em>. An InfluxDB database is very
much like what a database is in MySQL, it’s a collection of other
things.</p>

<p>“Other things” are called <em>data points</em>, <em>series</em>, <em>measurements</em>,
<em>tags</em> and <em>retention policies</em>. Under the hood (i.e. you never deal
with them directly) there are <em>shards</em> and <em>shard groups</em>.</p>

<p>The very first thing you need to do in InfluxDB is create a database
and at least one retention policy for this database. Once you have
these two things, you can start writing data.</p>

<p>A retention policy is the time period after which the data expires. It
can be set to be infinite. A data point, which is a measurement
consisting of any number of values and tags associated with a
particular point in time, must be associated with a database and a
retention policy. A retention policy also specifies the <em>replication
factor</em> for the data point.</p>

<p>Let’s say we are tracking disk usage across a whole bunch of
servers. Each server runs some sort of an agent which periodically
reports the usage of each disk to InfluxDB. Such a report might look
like this (in JSON):</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{"database" : "foo", "retentionPolicy" : "bar",
</span><span class="line"> "points" : [
</span><span class="line">   {"name" : "disk",
</span><span class="line">    "tags" : {"server" : "bwi23", "unit" : "1"},
</span><span class="line">    "timestamp" : "2015-03-16T01:02:26.234Z",
</span><span class="line">    "fields" : {"total" : 100, "used" : 40, "free" : 60}}]}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In the above example, “disk” is a measurement. Thus we can operate on
anything “disk”, regardless of what “server” or “unit” it applies
to. The data point as a whole belongs to a (time) series identified by
the combination of the measurement name and the tags.</p>

<p>There is no need to create series or measurements, they are created on
the fly.</p>

<p>To list the measurements, we can use <code>SHOW MEASUREMENTS</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&gt; show measurements
</span><span class="line">name            tags    name
</span><span class="line">----            ----    ----
</span><span class="line">measurements            disk</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>We can use <code>SHOW SERIES</code> to list the series:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&gt; show series
</span><span class="line">name    tags    id      server   unit
</span><span class="line">----    ----    --      -------  ----
</span><span class="line">disk            1       bw123    1</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If we send a record that contains different tags, we automatically
create a different series (or so it seems), for example if we send
this (note we changed “unit” to “foo”):</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{"database" : "foo", "retentionPolicy" : "bar",
</span><span class="line"> "points" : [
</span><span class="line">   {"name" : "disk",
</span><span class="line">    "tags" : {"server" : "bwi23", "foo" : "bar"},
</span><span class="line">    "timestamp" : "2015-03-16T01:02:26.234Z",
</span><span class="line">    "fields" : {"total" : 100, "used" : 40, "free" : 60}}]}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>we get</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&gt; show series
</span><span class="line">name    tags    id      foo     server  unit
</span><span class="line">----    ----    --      ---     ------  ----
</span><span class="line">disk            1               bwi23   1
</span><span class="line">disk            2       bar     bwi23</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This is where the distinction between measurement and series becomes a
little confusing to me. In actuality (from looking at the code and the
actual files InfluxDB created) there is only one series here called
“disk”. I understand the intent, but not sure that <em>series</em> is the
right terminology here. I think I’d prefer if measurements were simply
called series, and to get the equivalent of <code>SHOW SERIES</code> you’d use
something like <code>SHOW SERIES TAGS</code>. (May be I’m missing something.)</p>

<p>Under the hood the data is stored in shards, which are grouped by
shard groups, which in turn are grouped by retention policies, and
finally databases.</p>

<p>A database contains one or more retention policies. Somewhat
surprisingly a retention policy is actually a bucket. It makes sense
if you think about the problem of having to expire data points - you
can remove them all by simply dropping the entire bucket.</p>

<p>If we declare a retention policy of 1 day, then we can logically
divide the timeline into a sequence of single days from beginning of
the epoch. Any incoming data point falls into its corresponding
segment, which is a retention policy bucket. When clean up time comes
around, we can delete all days except for the most current day.</p>

<p>To better understand the following paragraphs, consider that having
multiple nodes provides the option for two things: <em>redundancy</em> and
<em>distribution</em>. Redundancy gives you the ability to lose a node
without losing any data. The number of copies of the data is
controlled by the replication factor specified as part of the
retention policy. Distribution spreads the data across nodes which
allows for concurrency: data can be written, read and processed in
parallel. For example if we become constrained by write performance,
we can solve this by simply adding more nodes. InfluxDB favors
redundancy over distribution when having to choose between the two.</p>

<p>Each retention policy bucket is further divided into shard groups, one
shard group per series. The purpose of a shard group is to balance
series data across the nodes of the cluster. If we have a cluster of 3
nodes, we want the data points to be evenly distributed across these
nodes. InfluxDB will create 3 shards, one on each of the nodes. The 3
shards comprise the shard group. This is assuming the replication
factor is 1.</p>

<p>But if the replication factor was 2, then there needs to be 2
identical copies of every shard. The shard copies must be on separate
nodes. With 3 nodes and replication factor of 2, it is impossible to
do any distribution across the nodes - the shard group will have a
size of 1, and contain 1 shard, replicated across 2 nodes. In this set
up, the third node will have no data for this particular retention
policy.</p>

<p>If we had a cluster of 5 nodes and the replication factor of 2, then
the shard group can have a size of 2, for 2 shards, replicated across
2 nodes each. Shard one replicas could live on nodes 1 and 3, while
shard two replicas on nodes 2 and 4. Now the data is distributed as
well as redundant. Note that the 5th node doesn’t do anything. If we
up the replication factor to 3 then just like before, the cluster is
too small to have any distribution, we only have enough nodes for
redundancy.</p>

<p>As of RC15 distributed queries are not yet implemented, so you will
always get an error if you have more than one shard in a group.</p>

<p>The shards themselves are instances of <a href="https://github.com/boltdb/bolt">Bolt db</a> - a simple to use key/value store
written in Go. There is also a separate Bolt db file called meta which
stores the metadata, i.e. information about databases, retention
policies, measurements, series, etc.</p>

<p>I couldn’t quite figure out the process for typical cluster operations
such as recovery from node failure or what happens (or should happen)
when nodes are added to existing cluster, whether there is a way to
decommission a node or re-balance the cluster similar to the Hadoop
balancer, etc. I think as of this writing this has not been fully
implemented yet, and there is no documentation, but hopefully it’s
coming soon.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/19/ruby_hiveserver2_and_kerberos/">Ruby, HiveServer2 and Kerberos</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-19T08:03:00-04:00" pubdate data-updated="true">Aug 19<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/08/19/ruby_hiveserver2_and_kerberos/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Recently I found myself needing to connect to HiveServer2 with
Kerberos authentication enabled from a Ruby app. As it turned out
<a href="https://github.com/forward3d/rbhive">rbhive gem</a> we were using did not have
support for Kerberos authentication. So I had to
<a href="https://github.com/forward3d/rbhive/pull/23">roll my own</a>.</p>

<p>This post is to document the experience of figuring out the details of
a SASL/GSSAPI connection before it is lost forever in my neurons and synapses.</p>

<p>First, the terminology. The authentication system that Hadoop uses is
<em>Kerberos</em>. Note that <a href="http://www.ietf.org/rfc/rfc4120.txt">Kerberos</a> is not a
network protocol. It describes the method by which
authentication happens, but not the format of how to send Kerberos
tickets and what not over the wire. For that, you need <em>SASL</em> and
<em>GSSAPI</em>.</p>

<p><a href="http://tools.ietf.org/html/rfc2222">SASL</a> is a generic protocol
designed to be able to wrap just about any authentication
handshake. It’s very simple: the client sends a START followed by some
payload, and expects an OK, BAD or COMPLETE from the server. OK means
that there are more steps to this conversation, BAD is
self-explanatory and COMPLETE means “I’m satisfied”. The objective is
to go from START via a series of OK’s to each side sending the other a
COMPLETE.</p>

<p>SASL doesn’t define the payload of each message. The payload is
specified by <a href="http://tools.ietf.org/html/rfc2743">GSSAPI</a>
protocol. GSSAPI is another generic protocol. Unlike SASL it is
actually very complex and covers a variety of authentication methods,
including Kerberos.</p>

<p>The combination of SASL and GSSAPI and what happens at the network
layer is documented in
<a href="http://tools.ietf.org/html/rfc4752">RFC4752</a>.</p>

<p>Bottom line is you need to read at least four RFC’s to be able to
understand every detail of this process:
<a href="http://tools.ietf.org/html/rfc4120">RFC4120</a>,
<a href="http://tools.ietf.org/html/rfc2222">RFC2222</a>,
<a href="http://tools.ietf.org/html/rfc2743">RFC2743</a> and
<a href="http://tools.ietf.org/html/rfc4752">RFC4752</a>. Fun!</p>

<h2 id="the-handshake-in-ruby">The Handshake in Ruby</h2>

<p>First, you’ll need some form of binding to the GSSAPI libraries. I’ve
been using the most excellent <a href="https://github.com/zenchild/gssapi">GSSAPI gem</a>
by <a href="http://distributed-frostbite.blogspot.ru/">Dan Wanek</a> which wraps the MIT GSSAPI library.</p>

<p>If you follow the code in
<a href="https://github.com/grisha/rbhive/blob/gssapi/lib/thrift/sasl_client_transport.rb">sasl_client_transport.rb</a>,
you’ll see the following steps are required to establish a connection.</p>

<p>First, we instantiate a GSSAPI object passing it the remote host and
the remote principal. Note that there is no TCP port number to be
specifies anywhere, because this isn’t to establish a TCP connection,
but only for Kerberos <em>host authentication</em>. (Kerberos requires that
not only the client authenticates itself to the host, but also that
the host authenticates itself to the client.)</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"><span class="c1"># Thrift::SaslClientTransport.initialize()</span>
</span><span class="line"><span class="vi">@gsscli</span> <span class="o">=</span> <span class="ss">GSSAPI</span><span class="p">:</span><span class="ss">:Simple</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@sasl_remote_host</span><span class="p">,</span> <span class="vi">@sasl_remote_principal</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The rest of the action takes place in the
<code>initiate_hand_shake_gssapi()</code> method.</p>

<p>First, we call <code>@gsscli.init_context()</code> with no arguments. This call
creates a token based on our current Kerberos credentials. (If there
are no credentials in our cache, this call will fail).</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="n">token</span> <span class="o">=</span> <span class="vi">@gsscli</span><span class="o">.</span><span class="n">init_context</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next we compose a SASL message which consists of START (0x01)
followed by payload length, followed by the actual payload, which is
the SASL mechanism name: ‘GSSAPI’. Without waiting for response, we
also send an OK (0x02) and the token returned from init_context().</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="n">header</span> <span class="o">=</span> <span class="o">[</span><span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:START</span><span class="o">]</span><span class="p">,</span> <span class="vi">@sasl_mechanism</span><span class="o">.</span><span class="n">length</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;cl&gt;&#39;</span><span class="p">)</span>
</span><span class="line">  <span class="vi">@transport</span><span class="o">.</span><span class="n">write</span> <span class="n">header</span> <span class="o">+</span> <span class="vi">@sasl_mechanism</span>
</span><span class="line">  <span class="n">header</span> <span class="o">=</span> <span class="o">[</span><span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:OK</span><span class="o">]</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">length</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;cl&gt;&#39;</span><span class="p">)</span>
</span><span class="line">  <span class="vi">@transport</span><span class="o">.</span><span class="n">write</span> <span class="n">header</span> <span class="o">+</span> <span class="n">token</span>
</span><span class="line">  <span class="n">status</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="vi">@transport</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="no">STATUS_BYTES</span> <span class="o">+</span> <span class="no">PAYLOAD_LENGTH_BYTES</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;cl&gt;&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Next we read 5 bytes of response. The first byte is the status
returned from the server, which hopefully is OK, followed by the
length of the payload, and then we read the payload itself:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="n">status</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="vi">@transport</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="no">STATUS_BYTES</span> <span class="o">+</span> <span class="no">PAYLOAD_LENGTH_BYTES</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;cl&gt;&#39;</span><span class="p">)</span>
</span><span class="line">  <span class="k">case</span> <span class="n">status</span>
</span><span class="line">  <span class="k">when</span> <span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:BAD</span><span class="o">]</span><span class="p">,</span> <span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:ERROR</span><span class="o">]</span>
</span><span class="line">    <span class="k">raise</span> <span class="vi">@transport</span><span class="o">.</span><span class="n">to_io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">len</span><span class="p">)</span>
</span><span class="line">  <span class="k">when</span> <span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:COMPLETE</span><span class="o">]</span>
</span><span class="line">    <span class="k">raise</span> <span class="s2">&quot;Not expecting COMPLETE at initial stage&quot;</span>
</span><span class="line">  <span class="k">when</span> <span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:OK</span><span class="o">]</span>
</span><span class="line">    <span class="n">challenge</span> <span class="o">=</span> <span class="vi">@transport</span><span class="o">.</span><span class="n">to_io</span><span class="o">.</span><span class="n">read</span> <span class="n">len</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The payload is a <em>challenge</em> created for us by the server. We can
verify this challenge by calling <code>init_context()</code> a second time, this
time passing in the challenge to verify it:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">    <span class="n">challenge</span> <span class="o">=</span> <span class="vi">@transport</span><span class="o">.</span><span class="n">to_io</span><span class="o">.</span><span class="n">read</span> <span class="n">len</span>
</span><span class="line">    <span class="k">unless</span> <span class="vi">@gsscli</span><span class="o">.</span><span class="n">init_context</span><span class="p">(</span><span class="n">challenge</span><span class="p">)</span>
</span><span class="line">      <span class="k">raise</span> <span class="s2">&quot;GSSAPI: challenge provided by server could not be verified&quot;</span>
</span><span class="line">    <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If the challenge verifies, then it is our turn to send an OK (with an
empty payload this time):</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">    <span class="n">header</span> <span class="o">=</span> <span class="o">[</span><span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:OK</span><span class="o">]</span><span class="p">,</span> <span class="mi">0</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;cl&gt;&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="vi">@transport</span><span class="o">.</span><span class="n">write</span> <span class="n">header</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>At this point in the SASL ‘conversation’ we have verified that the
server is who they claim to be.</p>

<p>Next the server sends us another challenge, this one is so that we can
authenticate ourselves to the server and at the same time agree on the
<em>protection level</em> for the communication channel.</p>

<p>We need to decrypt (“unwrap” in the GSSAPI terminology) the challenge,
examine the protection level and if it is acceptable, encrypt it on
our side and send it back to the server in a SASL COMPLETE message. In
this particular case we’re agreeable to any level of protection (which
is none in case of HiveServer2, i.e. the conversation is not
encrypted). Otherwise there are additional steps that RFC4752
describes whereby the client can select an acceptable protection
level.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">    <span class="n">status2</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="vi">@transport</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="no">STATUS_BYTES</span> <span class="o">+</span> <span class="no">PAYLOAD_LENGTH_BYTES</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;cl&gt;&#39;</span><span class="p">)</span>
</span><span class="line">    <span class="k">case</span> <span class="n">status2</span>
</span><span class="line">    <span class="k">when</span> <span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:BAD</span><span class="o">]</span><span class="p">,</span> <span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:ERROR</span><span class="o">]</span>
</span><span class="line">      <span class="k">raise</span> <span class="vi">@transport</span><span class="o">.</span><span class="n">to_io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">len</span><span class="p">)</span>
</span><span class="line">    <span class="k">when</span> <span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:COMPLETE</span><span class="o">]</span>
</span><span class="line">      <span class="k">raise</span> <span class="s2">&quot;Not expecting COMPLETE at second stage&quot;</span>
</span><span class="line">    <span class="k">when</span> <span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:OK</span><span class="o">]</span>
</span><span class="line">      <span class="n">challenge</span> <span class="o">=</span> <span class="vi">@transport</span><span class="o">.</span><span class="n">to_io</span><span class="o">.</span><span class="n">read</span> <span class="n">len</span>
</span><span class="line">      <span class="n">unwrapped</span> <span class="o">=</span> <span class="vi">@gsscli</span><span class="o">.</span><span class="n">unwrap_message</span><span class="p">(</span><span class="n">challenge</span><span class="p">)</span>
</span><span class="line">      <span class="n">rewrapped</span> <span class="o">=</span> <span class="vi">@gsscli</span><span class="o">.</span><span class="n">wrap_message</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">)</span>
</span><span class="line">      <span class="n">header</span> <span class="o">=</span> <span class="o">[</span><span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:COMPLETE</span><span class="o">]</span><span class="p">,</span> <span class="n">rewrapped</span><span class="o">.</span><span class="n">length</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;cl&gt;&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="vi">@transport</span><span class="o">.</span><span class="n">write</span> <span class="n">header</span> <span class="o">+</span> <span class="n">rewrapped</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The server should then respond with COMPLETE as well, at which point
we’re done with the authentication process and cat start sending
whatever we want over this connection:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">      <span class="n">status3</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="vi">@transport</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="no">STATUS_BYTES</span> <span class="o">+</span> <span class="no">PAYLOAD_LENGTH_BYTES</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;cl&gt;&#39;</span><span class="p">)</span>
</span><span class="line">      <span class="k">case</span> <span class="n">status3</span>
</span><span class="line">      <span class="k">when</span> <span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:BAD</span><span class="o">]</span><span class="p">,</span> <span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:ERROR</span><span class="o">]</span>
</span><span class="line">        <span class="k">raise</span> <span class="vi">@transport</span><span class="o">.</span><span class="n">to_io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">len</span><span class="p">)</span>
</span><span class="line">      <span class="k">when</span> <span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:COMPLETE</span><span class="o">]</span>
</span><span class="line">        <span class="vi">@transport</span><span class="o">.</span><span class="n">to_io</span><span class="o">.</span><span class="n">read</span> <span class="n">len</span>
</span><span class="line">        <span class="vi">@sasl_complete</span> <span class="o">=</span> <span class="kp">true</span>
</span><span class="line">      <span class="k">when</span> <span class="no">NEGOTIATION_STATUS</span><span class="o">[</span><span class="ss">:OK</span><span class="o">]</span>
</span><span class="line">        <span class="k">raise</span> <span class="s2">&quot;Failed to complete GSS challenge exchange&quot;</span>
</span><span class="line">      <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    

<section>
<script type="text/javascript"><!--
google_ad_client = "pub-9718360309690383";
google_ad_width = 200;
google_ad_height = 200;
google_ad_format = "200x200_as";
google_ad_type = "image";
//-->
</script>
<div style="text-align: center;">
  <div style="text-align: left; width: 200px; display: block; margin-left: auto; margin-right: auto;">
    <script type="text/javascript"
            src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
    </script>
  </div>
</div>
</section>

<section>
  <h1>About Me</h1>

  <p>
  <div style="width: 50%; margin: 0 auto;">
  <a href="http://twitter.com/humblehack" class="twitter-follow-button"
    data-show-count="">Follow @humblehack</a>
  </div>
  </p>

  <p>I am currently a (Data) Hacker at <a href="http://voxmedia.com">Vox Media</a>.</p>
  <p>Grisha is a common Russian short name for Gregory. It is pronounced more like Greesha.</p>
  <p>Years ago I wrote <a href="http://modpython.org">mod_python</a>, which became a hugely succesful OSS Project and is still in use by millions of sites.</p>
  <p>I am a former VP and member emeritus of the <a href="http://apache.org">Apache Software Foundation</a>.</p>
  <p>I started programming professionally back when I was a teenager.
  I&#8217;ve spent most of my early career working at large ISP&#8217;s solving industrial-scale hosting challenges. Since around 2009 I&#8217;ve become more intersted in and now work exclusively on data infrastuctre, both big and small, but mostly big.</p>
  <p>I was born and grew up in Moscow, Russia, though I&#8217;ve lived in the Washington, DC (USA) area for more than half of my life now. Our kids were born and go to school here, it&#8217;s gradually become home for us.</p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/07/29/state-of-tgres-2016/">Introducing Tgres - A Time Series DB on top of PostgreSQL</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/19/deploying-a-golang-app-to-aws-ecs-with-terraform/">Deploying a Golang app to AWS ECS with Terraform</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/17/triple-exponential-smoothing-forecasting-part-iii/">Holt-Winters Forecasting for Dummies - Part III</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/16/triple-exponential-smoothing-forecasting-part-ii/">Holt-Winters Forecasting for Dummies - Part II</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/29/triple-exponential-smoothing-forecasting/">Holt-Winters Forecasting for Dummies (or Developers) - Part I</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  <img src="http://www.ispol.com/grisha_org.gif" height="1" width="1">
  Copyright &copy; 2016 - Gregory Trubetskoy -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'grisha';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
