---
layout: post
title: "Blockchain Proof-Of-Work is a Decentralized Clock"
date: 2018-01-23 11:41
comments: true
categories:
published: true
---

This is an explanation of the key function on Proof-Of-Work in the
Bitcoin blockchain.  It focuses on the one feature of Proof-Of-Work
that is essential and shows that other features often talked about
such as security are secondary side-effects, useful, but not
essential.

Note that this write up isn't about Proof-Of-Work _per se_, it explains why the
blockchain needs it. If you do not know anything about Proof-Of-Work,
then [this](https://en.bitcoin.it/wiki/Proof_of_work) link might be a
good start.

This explanation rests on illustrating a few interesting properties of
Proof-Of-Work and the blockchain that are not immediately obvious and
sometimes are rather counter-intuitive. These are listed below.

Having understood each of these properties, one should conclude that
Proof-Of-Work is really a mechanism which accomplishes a distributed
and decentralized system of timing, i.e. a clock.

## The Decentralized Ledger Time Ordering Problem ##

Any ledger absolutely needs order. One cannot spend money that has not
been received, nor can one spend money that is already
spent. Blockchain transactions must be ordered in time, unambiguously,
and without the need for a trusted third party.

But if transactions are generated by anonymous participants all over
the world, and no central party is responsible for organizing the
list, how can it be done? For example transactions could include
timestamps, but how could timestamps be trusted?

Time is but a human concept, and any source of it, such as an atomic
clock, is a "trusted third party" (which on top of everything is
slightly wrong most of time due to network delays as well as
the effects of relativity). Paradoxically, relying on a timestamp to
determine event order is not possible in a decentralized system.

This problem is well described in
[Leslie Lamport's](https://en.wikipedia.org/wiki/Leslie_Lamport) 1978 paper
["Time, Clocks, and the Ordering of Events in a Distributed System"](https://amturing.acm.org/p558-lamport.pdf)
which doesn't actually provide a comprehensive solution other than
"properly synchronized physical clocks". In 1982 Lamport also
described the ["Byzantine Generals Problem"](https://people.eecs.berkeley.edu/~luca/cs174/byzantine.pdf),
and Satoshi in one of his first emails [explains](http://satoshi.nakamotoinstitute.org/emails/cryptography/11/),
explains how Proof-Of-Work is a solution.

## Timing is the Root Problem ##

It must be stressed that the _impossibility of ordering by time_ was the unsolved problem that
precluded a decentralized ledger from ever being possible until
Satoshi Nakamoto invented a [solution](https://bitcoin.org/bitcoin.pdf).
There are many other technical details that
play into the blockchain, but timing is fundamental and paramount.
Without timing there is no blockchain.

## Proof-Of-Work Recap ##

Very briefly, the Bitcoin Proof-Of-Work is a value whose
[SHA-2](https://en.wikipedia.org/wiki/SHA-2) hash
conforms to a certain requirement which makes such a value difficult
to find. The difficulty is established by requiring that the hash is
less than a specific number, the smaller the number, the more rare the
input value and the higher the difficulty of finding it.

It is called "Proof Of Work" because it is known that a value with
such a hash is extremely rare, which means that finding such a value
requires a lot of trial and error, i.e. "work". Work in turn implies
_time_.

By varying the requirement, we can vary the difficulty and thus the
probability of such a hash being found. The Bitcoin Difficulty adjusts
dynamically so that a proper hash is found on average once every ten
minutes.

## Nothing Happens Between Blocks ##

The state of the chain is reflected by its blocks, and each new block
produces a new state. The blockchain state moves forward one block at
a time, and the average 10 minutes of a block is the smallest measure
of blockchain time.

## SHA is Memoryless and Progress-Free ##

The Secure Hash Algorithm is what is known in statistics and
probability as [_memoryless_](https://en.wikipedia.org/wiki/Memorylessness).
This is a property that is particularly counter-intuitive for us humans.

The best example of memoryless-ness is a coin toss. If a coin comes up
heads 10 times in a row, does it mean that the next toss is more
likely to be tails? Our intuition says yes, but in reality each toss
has a 50/50 chance of either outcome regardless of what happened in
the past.

Memorylessness is required for the problem to be _progress-free_.
Progress-free means that as miners try to solve blocks iterating
over [nonces](https://en.bitcoin.it/wiki/Nonce), each attempt is a
stand-alone event and the probability of finding a solution is
constant at each attempt, regardless of how much work has been done in
the past. In other words at each attempt the participant is not
getting any "closer" to a solution i.e. making no progress.

The probability of finding the solution given a specific difficulty in
a given period of time is therefore determined _solely by the speed at
which all participants can crunch through the hashes_. Not the prior
history, not the data, just the hashrate.

The hashrate in turn is a function of the number of participants and
the speed of the equipment used to calculate the hash.

## The SHA Input Is Irrelevant ##

In the Bitcoin blockchain the input is a block header.
But if we just fed it random values, the probability of finding a
conforming hash would _still be the same_. Regardless of whether the
input is a valid block header or bytes from /dev/random, it is going
to take 10 minutes on average to find a solution.

Of course if you find a conforming hash but your input wasn't a valid
block, such a solution cannot be added to the blockchain, but it is
still Proof-Of-Work (albeit useless).

## The Difficulty is Intergalactic ##

Curiously, the difficulty is *universal*, meaning it spans the entire
universe. We could have miners on Mars helping out, they do not need
know or communicate with the Earth miners, the problem would still be
solved every 10 minutes. (Ok, they'll need to somehow tell the Earth
people that they solved it if they do, or else we'll never know about
it.)

Remarkably, the distant participants are communicating without
actually communicating, because they are collectively solving the same
statistical problem and yet they're not even aware of each other's
existence.

This "universal property" while at first seemingly magical is actually
easy to explain. I used the term "universal" because it describes it
well in one word, but really it means "known by every participant".

The input to SHA-256 can be thought of as an integer between 0 and
2<sup>256</sup> (because the output is 32 bytes, i.e. also between 0
and 2<sup>256</sup>, anything larger guarantees a collision,
i.e. becomes redundant). Even though it is extremely large
([exponentially larger](https://learncryptography.com/cryptanalysis/why-is-2-256-secure)
than the number of atoms in the perceivable universe), it is a set of numbers that is known by every participant
and the participants can only pick from this set.

If the input set is universally known, the function (SHA-256) is
universally known, as well as the difficulty requirement is universally known,
then the probability of finding a solution is also indeed "universal".

## Trying a SHA Makes You a Participant ##

If the stated problem is to find a conforming hash, all you have to do
is to try it once, and bingo, you've affected the global hash rate,
and for that one attempt you were a participant helping others solve
the problem. You did not need to tell others that you did it (unless
you actually found a solution), others didn't need to know about it,
but your attempt _did_ affect the outcome. For the whole universe, no
less.

If the above still seems suspicious, a good analogy might
be the problem of finding large prime numbers. Finding the largest
prime number is hard and once one is found, it becomes "discovered" or
"known". There is an infinite number of prime numbers, but only one
instance of each number in the universe. Therefore whoever attempts to
find the largest prime is working on the same problem, not a separate
instance of it. You do not need to tell anyone you decided to look for
the largest prime, you only need to announce when you find one. If no
one ever looks for the largest prime, then it is never going to be
found. Thus, participation (i.e. an attempt to find one), even if it's
in total secrecy, still affects the outcome.

Taking advantage of this mind-boggling statistical phenomenon whereby
any participation, even in complete secrecy, affects the outcome _is_
what makes Satoshi's invention so remarkably brilliant.

It is noteworthy that since SHA is progress-free, each attempt could be
thought of as a participant joining the effort and immediately
leaving. Thus miners join and leave, trillions of times per second.

## Work is a Clock ##

And there is the crux of it: The difficulty in finding a conforming
hash acts as _a clock_. It doesn't matter that this clock is
imprecise. What matters is that the state of the chain can be tied
unambiguously to the ticks of such a clock.

This clock is operated by the multi-terahash rate of an unknown
number of collective participants spread across the planet,
independent of one another.

## Last Piece of the Puzzle ##

It must be the hash of a block (the block header, to be precise). As
we mentioned, the input doesn't matter, but if it is an actual block,
then whenever a solution is found, it happened at the tick of our
Proof-Of-Work clock. Not before, not after, but exactly at. We know
this unambiguosly because the block was part of that mechanism.

To put it another way, if blocks weren't the input to the SHA256
function, we'd still have a distributed clock, but we couldn't tie blocks to
the ticks of this clock. Using the blocks addresses this issue.

## And that is it ##

This is what Proof-Of-Work does for the blockchain. It is not a
"lottery" where miners win the right to solve a block, nor is it some
peculiar conversion of real energy into a valuable concept, those
things are secondary.

For example the lottery and the miner's reward aspect is what
encourages miners to participate, but it isn't what makes the
blockchain possible. Blocks are a Merkle tree, but again, that has
nothing to do with Proof-Of-Work, it cryptographically reinforces
recording of the block ordering. Proof-Of-Work is also the mechanism
by which blocks become effectively immutable, and that's a nice
side-effect which makes Segregated Witness possible, but it could just
as well be done by preserving the signatures (witness), so this too is
secondary.

## Conclusion ##

The Bitcoin blockchain Proof-Of-Work is simply a distributed, decentralized clock.

If you understand this explanation, then you should have a much better
grasp of how Proof-Of-Work compares to [Proof-Of-Stake](https://en.wikipedia.org/wiki/Proof-of-stake),
and it should
be apparent that the two are not comparable: Proof-Of-Stake is about
(randomly distributed) authority, while Proof-Of-Work is a clock.

Proof-Of-Work is probably a misnomer. It is not about proving work, it
is about verifiably taking time. When I see a hash that satisfies the
difficulty, I know it must have taken time. The method by which the
delay is accomplished is "work", but the hash is a proof of _time_,
not work.

Figuring out a way to pace ticks without work is a trillion dollar
problem, if you find one, please do let me know!
