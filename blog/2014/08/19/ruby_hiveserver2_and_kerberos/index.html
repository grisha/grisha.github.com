<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Ruby, HiveServer2 and Kerberos - Gregory Trubetskoy</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="Recently I found myself needing to connect to HiveServer2 with Kerberos authentication enabled from a Ruby app. As it turned out rbhive gem we were using did not have support for Kerberos authentication. So I had to roll my own.
This post is to document the experience of figuring out the details of a SASL/GSSAPI connection before it is lost forever in my neurons and synapses.
First, the terminology. The authentication system that Hadoop uses is Kerberos. Note that Kerberos is not a network protocol. It describes the method by which authentication happens, but not the format of how to send Kerberos tickets and what not over the wire. For that, you need SASL and GSSAPI.
" />






<meta name="generator" content="Hugo 0.146.0 with theme even" />


<link rel="canonical" href="https://grisha.org/blog/2014/08/19/ruby_hiveserver2_and_kerberos/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">

<link rel="stylesheet" href="/css/custom.css">


<meta property="og:url" content="https://grisha.org/blog/2014/08/19/ruby_hiveserver2_and_kerberos/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="Ruby, HiveServer2 and Kerberos">
  <meta property="og:description" content="Recently I found myself needing to connect to HiveServer2 with Kerberos authentication enabled from a Ruby app. As it turned out rbhive gem we were using did not have support for Kerberos authentication. So I had to roll my own.
This post is to document the experience of figuring out the details of a SASL/GSSAPI connection before it is lost forever in my neurons and synapses.
First, the terminology. The authentication system that Hadoop uses is Kerberos. Note that Kerberos is not a network protocol. It describes the method by which authentication happens, but not the format of how to send Kerberos tickets and what not over the wire. For that, you need SASL and GSSAPI.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2014-08-19T08:03:00+00:00">
    <meta property="article:modified_time" content="2014-08-19T08:03:00+00:00">

  <meta itemprop="name" content="Ruby, HiveServer2 and Kerberos">
  <meta itemprop="description" content="Recently I found myself needing to connect to HiveServer2 with Kerberos authentication enabled from a Ruby app. As it turned out rbhive gem we were using did not have support for Kerberos authentication. So I had to roll my own.
This post is to document the experience of figuring out the details of a SASL/GSSAPI connection before it is lost forever in my neurons and synapses.
First, the terminology. The authentication system that Hadoop uses is Kerberos. Note that Kerberos is not a network protocol. It describes the method by which authentication happens, but not the format of how to send Kerberos tickets and what not over the wire. For that, you need SASL and GSSAPI.">
  <meta itemprop="datePublished" content="2014-08-19T08:03:00+00:00">
  <meta itemprop="dateModified" content="2014-08-19T08:03:00+00:00">
  <meta itemprop="wordCount" content="866">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Ruby, HiveServer2 and Kerberos">
  <meta name="twitter:description" content="Recently I found myself needing to connect to HiveServer2 with Kerberos authentication enabled from a Ruby app. As it turned out rbhive gem we were using did not have support for Kerberos authentication. So I had to roll my own.
This post is to document the experience of figuring out the details of a SASL/GSSAPI connection before it is lost forever in my neurons and synapses.
First, the terminology. The authentication system that Hadoop uses is Kerberos. Note that Kerberos is not a network protocol. It describes the method by which authentication happens, but not the format of how to send Kerberos tickets and what not over the wire. For that, you need SASL and GSSAPI.">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Gregory Trubetskoy</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/posts/">
        <li class="mobile-menu-item">Archives</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Gregory Trubetskoy</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/posts/">Archives</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Ruby, HiveServer2 and Kerberos</h1>

      <div class="post-meta">
        <span class="post-time"> 2014-08-19 </span>
        
        
      </div>
    </header>

    
    <div class="post-content">
      <p>Recently I found myself needing to connect to HiveServer2 with
Kerberos authentication enabled from a Ruby app. As it turned out
<a href="https://github.com/forward3d/rbhive">rbhive gem</a> we were using did not have
support for Kerberos authentication. So I had to
<a href="https://github.com/forward3d/rbhive/pull/23">roll my own</a>.</p>
<p>This post is to document the experience of figuring out the details of
a SASL/GSSAPI connection before it is lost forever in my neurons and synapses.</p>
<p>First, the terminology. The authentication system that Hadoop uses is
<em>Kerberos</em>. Note that <a href="http://www.ietf.org/rfc/rfc4120.txt">Kerberos</a> is not a
network protocol. It describes the method by which
authentication happens, but not the format of how to send Kerberos
tickets and what not over the wire. For that, you need <em>SASL</em> and
<em>GSSAPI</em>.</p>
<p><a href="http://tools.ietf.org/html/rfc2222">SASL</a> is a generic protocol
designed to be able to wrap just about any authentication
handshake. It&rsquo;s very simple: the client sends a START followed by some
payload, and expects an OK, BAD or COMPLETE from the server. OK means
that there are more steps to this conversation, BAD is
self-explanatory and COMPLETE means &ldquo;I&rsquo;m satisfied&rdquo;. The objective is
to go from START via a series of OK&rsquo;s to each side sending the other a
COMPLETE.</p>
<p>SASL doesn&rsquo;t define the payload of each message. The payload is
specified by <a href="http://tools.ietf.org/html/rfc2743">GSSAPI</a>
protocol. GSSAPI is another generic protocol. Unlike SASL it is
actually very complex and covers a variety of authentication methods,
including Kerberos.</p>
<p>The combination of SASL and GSSAPI and what happens at the network
layer is documented in
<a href="http://tools.ietf.org/html/rfc4752">RFC4752</a>.</p>
<p>Bottom line is you need to read at least four RFC&rsquo;s to be able to
understand every detail of this process:
<a href="http://tools.ietf.org/html/rfc4120">RFC4120</a>,
<a href="http://tools.ietf.org/html/rfc2222">RFC2222</a>,
<a href="http://tools.ietf.org/html/rfc2743">RFC2743</a> and
<a href="http://tools.ietf.org/html/rfc4752">RFC4752</a>. Fun!</p>
<h2 id="the-handshake-in-ruby">The Handshake in Ruby</h2>
<p>First, you&rsquo;ll need some form of binding to the GSSAPI libraries. I&rsquo;ve
been using the most excellent <a href="https://github.com/zenchild/gssapi">GSSAPI gem</a>
by <a href="http://distributed-frostbite.blogspot.ru/">Dan Wanek</a> which wraps the MIT GSSAPI library.</p>
<p>If you follow the code in
<a href="https://github.com/grisha/rbhive/blob/gssapi/lib/thrift/sasl_client_transport.rb">sasl_client_transport.rb</a>,
you&rsquo;ll see the following steps are required to establish a connection.</p>
<p>First, we instantiate a GSSAPI object passing it the remote host and
the remote principal. Note that there is no TCP port number to be
specifies anywhere, because this isn&rsquo;t to establish a TCP connection,
but only for Kerberos <em>host authentication</em>. (Kerberos requires that
not only the client authenticates itself to the host, but also that
the host authenticates itself to the client.)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#75715e"># Thrift::SaslClientTransport.initialize()</span>
</span></span><span style="display:flex;"><span>@gsscli <span style="color:#f92672">=</span> <span style="color:#66d9ef">GSSAPI</span><span style="color:#f92672">::</span><span style="color:#66d9ef">Simple</span><span style="color:#f92672">.</span>new(@sasl_remote_host, @sasl_remote_principal)
</span></span></code></pre></div><p>The rest of the action takes place in the
<code>initiate_hand_shake_gssapi()</code> method.</p>
<p>First, we call <code>@gsscli.init_context()</code> with no arguments. This call
creates a token based on our current Kerberos credentials. (If there
are no credentials in our cache, this call will fail).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>      token <span style="color:#f92672">=</span> @gsscli<span style="color:#f92672">.</span>init_context
</span></span></code></pre></div><p>Next we compose a SASL message which consists of START (0x01)
followed by payload length, followed by the actual payload, which is
the SASL mechanism name: &lsquo;GSSAPI&rsquo;. Without waiting for response, we
also send an OK (0x02) and the token returned from init_context().</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>      header <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:START</span><span style="color:#f92672">]</span>, @sasl_mechanism<span style="color:#f92672">.</span>length<span style="color:#f92672">].</span>pack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>      @transport<span style="color:#f92672">.</span>write header <span style="color:#f92672">+</span> @sasl_mechanism
</span></span><span style="display:flex;"><span>      header <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:OK</span><span style="color:#f92672">]</span>, token<span style="color:#f92672">.</span>length<span style="color:#f92672">].</span>pack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>      @transport<span style="color:#f92672">.</span>write header <span style="color:#f92672">+</span> token
</span></span><span style="display:flex;"><span>      status, len <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>read(<span style="color:#66d9ef">STATUS_BYTES</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">PAYLOAD_LENGTH_BYTES</span>)<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span></code></pre></div><p>Next we read 5 bytes of response. The first byte is the status
returned from the server, which hopefully is OK, followed by the
length of the payload, and then we read the payload itself:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>      status, len <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>read(<span style="color:#66d9ef">STATUS_BYTES</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">PAYLOAD_LENGTH_BYTES</span>)<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> status
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:BAD</span><span style="color:#f92672">]</span>, <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:ERROR</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read(len)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:COMPLETE</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#e6db74">&#34;Not expecting COMPLETE at initial stage&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:OK</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        challenge <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read len
</span></span></code></pre></div><p>The payload is a <em>challenge</em> created for us by the server. We can
verify this challenge by calling <code>init_context()</code> a second time, this
time passing in the challenge to verify it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>        challenge <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read len
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unless</span> @gsscli<span style="color:#f92672">.</span>init_context(challenge)
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">raise</span> <span style="color:#e6db74">&#34;GSSAPI: challenge provided by server could not be verified&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>If the challenge verifies, then it is our turn to send an OK (with an
empty payload this time):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>        header <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:OK</span><span style="color:#f92672">]</span>, <span style="color:#ae81ff">0</span><span style="color:#f92672">].</span>pack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>        @transport<span style="color:#f92672">.</span>write header
</span></span></code></pre></div><p>At this point in the SASL &lsquo;conversation&rsquo; we have verified that the
server is who they claim to be.</p>
<p>Next the server sends us another challenge, this one is so that we can
authenticate ourselves to the server and at the same time agree on the
<em>protection level</em> for the communication channel.</p>
<p>We need to decrypt (&ldquo;unwrap&rdquo; in the GSSAPI terminology) the challenge,
examine the protection level and if it is acceptable, encrypt it on
our side and send it back to the server in a SASL COMPLETE message. In
this particular case we&rsquo;re agreeable to any level of protection (which
is none in case of HiveServer2, i.e. the conversation is not
encrypted). Otherwise there are additional steps that RFC4752
describes whereby the client can select an acceptable protection
level.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>        status2, len <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>read(<span style="color:#66d9ef">STATUS_BYTES</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">PAYLOAD_LENGTH_BYTES</span>)<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> status2
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:BAD</span><span style="color:#f92672">]</span>, <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:ERROR</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">raise</span> @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read(len)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:COMPLETE</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">raise</span> <span style="color:#e6db74">&#34;Not expecting COMPLETE at second stage&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:OK</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>          challenge <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read len
</span></span><span style="display:flex;"><span>          unwrapped <span style="color:#f92672">=</span> @gsscli<span style="color:#f92672">.</span>unwrap_message(challenge)
</span></span><span style="display:flex;"><span>          rewrapped <span style="color:#f92672">=</span> @gsscli<span style="color:#f92672">.</span>wrap_message(unwrapped)
</span></span><span style="display:flex;"><span>          header <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:COMPLETE</span><span style="color:#f92672">]</span>, rewrapped<span style="color:#f92672">.</span>length<span style="color:#f92672">].</span>pack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>          @transport<span style="color:#f92672">.</span>write header <span style="color:#f92672">+</span> rewrapped
</span></span></code></pre></div><p>The server should then respond with COMPLETE as well, at which point
we&rsquo;re done with the authentication process and cat start sending
whatever we want over this connection:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>          status3, len <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>read(<span style="color:#66d9ef">STATUS_BYTES</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">PAYLOAD_LENGTH_BYTES</span>)<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">case</span> status3
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:BAD</span><span style="color:#f92672">]</span>, <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:ERROR</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">raise</span> @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read(len)
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:COMPLETE</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>            @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read len
</span></span><span style="display:flex;"><span>            @sasl_complete <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:OK</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">raise</span> <span style="color:#e6db74">&#34;Failed to complete GSS challenge exchange&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">end</span>
</span></span></code></pre></div>
    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/blog/2015/03/20/influxdb-data/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">How InfluxDB Stores Data</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/blog/2014/06/03/graceful-restart-in-golang/">
            <span class="next-text nav-default">Graceful restart in Golang</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'grisha';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2013 - 
    2026<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
