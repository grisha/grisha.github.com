<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Ruby, HiveServer2 and Kerberos | Gregory Trubetskoy</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Recently I found myself needing to connect to HiveServer2 with
Kerberos authentication enabled from a Ruby app. As it turned out
rbhive gem we were using did not have
support for Kerberos authentication. So I had to
roll my own.
This post is to document the experience of figuring out the details of
a SASL/GSSAPI connection before it is lost forever in my neurons and synapses.
First, the terminology. The authentication system that Hadoop uses is
Kerberos. Note that Kerberos is not a
network protocol. It describes the method by which
authentication happens, but not the format of how to send Kerberos
tickets and what not over the wire. For that, you need SASL and
GSSAPI.">
    <meta name="generator" content="Hugo 0.146.0">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    <meta name="author" content="Gregory Trubetskoy">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/blog/2014/08/19/ruby-hiveserver2-and-kerberos/">
    

    
    
    <meta property="og:url" content="http://localhost:1313/blog/2014/08/19/ruby-hiveserver2-and-kerberos/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="Ruby, HiveServer2 and Kerberos">
  <meta property="og:description" content="Recently I found myself needing to connect to HiveServer2 with Kerberos authentication enabled from a Ruby app. As it turned out rbhive gem we were using did not have support for Kerberos authentication. So I had to roll my own.
This post is to document the experience of figuring out the details of a SASL/GSSAPI connection before it is lost forever in my neurons and synapses.
First, the terminology. The authentication system that Hadoop uses is Kerberos. Note that Kerberos is not a network protocol. It describes the method by which authentication happens, but not the format of how to send Kerberos tickets and what not over the wire. For that, you need SASL and GSSAPI.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2014-08-19T08:03:00+00:00">
    <meta property="article:modified_time" content="2014-08-19T08:03:00+00:00">

  <meta itemprop="name" content="Ruby, HiveServer2 and Kerberos">
  <meta itemprop="description" content="Recently I found myself needing to connect to HiveServer2 with Kerberos authentication enabled from a Ruby app. As it turned out rbhive gem we were using did not have support for Kerberos authentication. So I had to roll my own.
This post is to document the experience of figuring out the details of a SASL/GSSAPI connection before it is lost forever in my neurons and synapses.
First, the terminology. The authentication system that Hadoop uses is Kerberos. Note that Kerberos is not a network protocol. It describes the method by which authentication happens, but not the format of how to send Kerberos tickets and what not over the wire. For that, you need SASL and GSSAPI.">
  <meta itemprop="datePublished" content="2014-08-19T08:03:00+00:00">
  <meta itemprop="dateModified" content="2014-08-19T08:03:00+00:00">
  <meta itemprop="wordCount" content="866">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Ruby, HiveServer2 and Kerberos">
  <meta name="twitter:description" content="Recently I found myself needing to connect to HiveServer2 with Kerberos authentication enabled from a Ruby app. As it turned out rbhive gem we were using did not have support for Kerberos authentication. So I had to roll my own.
This post is to document the experience of figuring out the details of a SASL/GSSAPI connection before it is lost forever in my neurons and synapses.
First, the terminology. The authentication system that Hadoop uses is Kerberos. Note that Kerberos is not a network protocol. It describes the method by which authentication happens, but not the format of how to send Kerberos tickets and what not over the wire. For that, you need SASL and GSSAPI.">

	
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$', '$'] ],
      displayMath: [ ['$$', '$$']],
      processEscapes: true,
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Gregory Trubetskoy
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/archives/" title="Archives page">
              Archives
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l mw7 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Ruby, HiveServer2 and Kerberos</h1>
      
      <p class="tracked"><strong>Gregory Trubetskoy</strong>
      </p>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2014-08-19T08:03:00Z">August 19, 2014</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-100-l"><p>Recently I found myself needing to connect to HiveServer2 with
Kerberos authentication enabled from a Ruby app. As it turned out
<a href="https://github.com/forward3d/rbhive">rbhive gem</a> we were using did not have
support for Kerberos authentication. So I had to
<a href="https://github.com/forward3d/rbhive/pull/23">roll my own</a>.</p>
<p>This post is to document the experience of figuring out the details of
a SASL/GSSAPI connection before it is lost forever in my neurons and synapses.</p>
<p>First, the terminology. The authentication system that Hadoop uses is
<em>Kerberos</em>. Note that <a href="http://www.ietf.org/rfc/rfc4120.txt">Kerberos</a> is not a
network protocol. It describes the method by which
authentication happens, but not the format of how to send Kerberos
tickets and what not over the wire. For that, you need <em>SASL</em> and
<em>GSSAPI</em>.</p>
<p><a href="http://tools.ietf.org/html/rfc2222">SASL</a> is a generic protocol
designed to be able to wrap just about any authentication
handshake. It&rsquo;s very simple: the client sends a START followed by some
payload, and expects an OK, BAD or COMPLETE from the server. OK means
that there are more steps to this conversation, BAD is
self-explanatory and COMPLETE means &ldquo;I&rsquo;m satisfied&rdquo;. The objective is
to go from START via a series of OK&rsquo;s to each side sending the other a
COMPLETE.</p>
<p>SASL doesn&rsquo;t define the payload of each message. The payload is
specified by <a href="http://tools.ietf.org/html/rfc2743">GSSAPI</a>
protocol. GSSAPI is another generic protocol. Unlike SASL it is
actually very complex and covers a variety of authentication methods,
including Kerberos.</p>
<p>The combination of SASL and GSSAPI and what happens at the network
layer is documented in
<a href="http://tools.ietf.org/html/rfc4752">RFC4752</a>.</p>
<p>Bottom line is you need to read at least four RFC&rsquo;s to be able to
understand every detail of this process:
<a href="http://tools.ietf.org/html/rfc4120">RFC4120</a>,
<a href="http://tools.ietf.org/html/rfc2222">RFC2222</a>,
<a href="http://tools.ietf.org/html/rfc2743">RFC2743</a> and
<a href="http://tools.ietf.org/html/rfc4752">RFC4752</a>. Fun!</p>
<h2 id="the-handshake-in-ruby">The Handshake in Ruby</h2>
<p>First, you&rsquo;ll need some form of binding to the GSSAPI libraries. I&rsquo;ve
been using the most excellent <a href="https://github.com/zenchild/gssapi">GSSAPI gem</a>
by <a href="http://distributed-frostbite.blogspot.ru/">Dan Wanek</a> which wraps the MIT GSSAPI library.</p>
<p>If you follow the code in
<a href="https://github.com/grisha/rbhive/blob/gssapi/lib/thrift/sasl_client_transport.rb">sasl_client_transport.rb</a>,
you&rsquo;ll see the following steps are required to establish a connection.</p>
<p>First, we instantiate a GSSAPI object passing it the remote host and
the remote principal. Note that there is no TCP port number to be
specifies anywhere, because this isn&rsquo;t to establish a TCP connection,
but only for Kerberos <em>host authentication</em>. (Kerberos requires that
not only the client authenticates itself to the host, but also that
the host authenticates itself to the client.)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#75715e"># Thrift::SaslClientTransport.initialize()</span>
</span></span><span style="display:flex;"><span>@gsscli <span style="color:#f92672">=</span> <span style="color:#66d9ef">GSSAPI</span><span style="color:#f92672">::</span><span style="color:#66d9ef">Simple</span><span style="color:#f92672">.</span>new(@sasl_remote_host, @sasl_remote_principal)
</span></span></code></pre></div><p>The rest of the action takes place in the
<code>initiate_hand_shake_gssapi()</code> method.</p>
<p>First, we call <code>@gsscli.init_context()</code> with no arguments. This call
creates a token based on our current Kerberos credentials. (If there
are no credentials in our cache, this call will fail).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>      token <span style="color:#f92672">=</span> @gsscli<span style="color:#f92672">.</span>init_context
</span></span></code></pre></div><p>Next we compose a SASL message which consists of START (0x01)
followed by payload length, followed by the actual payload, which is
the SASL mechanism name: &lsquo;GSSAPI&rsquo;. Without waiting for response, we
also send an OK (0x02) and the token returned from init_context().</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>      header <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:START</span><span style="color:#f92672">]</span>, @sasl_mechanism<span style="color:#f92672">.</span>length<span style="color:#f92672">].</span>pack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>      @transport<span style="color:#f92672">.</span>write header <span style="color:#f92672">+</span> @sasl_mechanism
</span></span><span style="display:flex;"><span>      header <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:OK</span><span style="color:#f92672">]</span>, token<span style="color:#f92672">.</span>length<span style="color:#f92672">].</span>pack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>      @transport<span style="color:#f92672">.</span>write header <span style="color:#f92672">+</span> token
</span></span><span style="display:flex;"><span>      status, len <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>read(<span style="color:#66d9ef">STATUS_BYTES</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">PAYLOAD_LENGTH_BYTES</span>)<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span></code></pre></div><p>Next we read 5 bytes of response. The first byte is the status
returned from the server, which hopefully is OK, followed by the
length of the payload, and then we read the payload itself:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>      status, len <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>read(<span style="color:#66d9ef">STATUS_BYTES</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">PAYLOAD_LENGTH_BYTES</span>)<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> status
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:BAD</span><span style="color:#f92672">]</span>, <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:ERROR</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read(len)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:COMPLETE</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#e6db74">&#34;Not expecting COMPLETE at initial stage&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:OK</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        challenge <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read len
</span></span></code></pre></div><p>The payload is a <em>challenge</em> created for us by the server. We can
verify this challenge by calling <code>init_context()</code> a second time, this
time passing in the challenge to verify it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>        challenge <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read len
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unless</span> @gsscli<span style="color:#f92672">.</span>init_context(challenge)
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">raise</span> <span style="color:#e6db74">&#34;GSSAPI: challenge provided by server could not be verified&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>If the challenge verifies, then it is our turn to send an OK (with an
empty payload this time):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>        header <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:OK</span><span style="color:#f92672">]</span>, <span style="color:#ae81ff">0</span><span style="color:#f92672">].</span>pack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>        @transport<span style="color:#f92672">.</span>write header
</span></span></code></pre></div><p>At this point in the SASL &lsquo;conversation&rsquo; we have verified that the
server is who they claim to be.</p>
<p>Next the server sends us another challenge, this one is so that we can
authenticate ourselves to the server and at the same time agree on the
<em>protection level</em> for the communication channel.</p>
<p>We need to decrypt (&ldquo;unwrap&rdquo; in the GSSAPI terminology) the challenge,
examine the protection level and if it is acceptable, encrypt it on
our side and send it back to the server in a SASL COMPLETE message. In
this particular case we&rsquo;re agreeable to any level of protection (which
is none in case of HiveServer2, i.e. the conversation is not
encrypted). Otherwise there are additional steps that RFC4752
describes whereby the client can select an acceptable protection
level.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>        status2, len <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>read(<span style="color:#66d9ef">STATUS_BYTES</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">PAYLOAD_LENGTH_BYTES</span>)<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> status2
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:BAD</span><span style="color:#f92672">]</span>, <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:ERROR</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">raise</span> @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read(len)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:COMPLETE</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">raise</span> <span style="color:#e6db74">&#34;Not expecting COMPLETE at second stage&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:OK</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>          challenge <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read len
</span></span><span style="display:flex;"><span>          unwrapped <span style="color:#f92672">=</span> @gsscli<span style="color:#f92672">.</span>unwrap_message(challenge)
</span></span><span style="display:flex;"><span>          rewrapped <span style="color:#f92672">=</span> @gsscli<span style="color:#f92672">.</span>wrap_message(unwrapped)
</span></span><span style="display:flex;"><span>          header <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:COMPLETE</span><span style="color:#f92672">]</span>, rewrapped<span style="color:#f92672">.</span>length<span style="color:#f92672">].</span>pack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>          @transport<span style="color:#f92672">.</span>write header <span style="color:#f92672">+</span> rewrapped
</span></span></code></pre></div><p>The server should then respond with COMPLETE as well, at which point
we&rsquo;re done with the authentication process and cat start sending
whatever we want over this connection:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>          status3, len <span style="color:#f92672">=</span> @transport<span style="color:#f92672">.</span>read(<span style="color:#66d9ef">STATUS_BYTES</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">PAYLOAD_LENGTH_BYTES</span>)<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;cl&gt;&#39;</span>)
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">case</span> status3
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:BAD</span><span style="color:#f92672">]</span>, <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:ERROR</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">raise</span> @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read(len)
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:COMPLETE</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>            @transport<span style="color:#f92672">.</span>to_io<span style="color:#f92672">.</span>read len
</span></span><span style="display:flex;"><span>            @sasl_complete <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">NEGOTIATION_STATUS</span><span style="color:#f92672">[</span><span style="color:#e6db74">:OK</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">raise</span> <span style="color:#e6db74">&#34;Failed to complete GSS challenge exchange&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">end</span>
</span></span></code></pre></div><ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  Gregory Trubetskoy 2026 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
