<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>PostgreSQL vs Whisper, which is Faster? - Gregory Trubetskoy</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="Note: there is an update to this post.
TL;DR On a 8 CPU / 16 GB EC2 instance, Tgres can process 150,000 data points per second across 300,000 series (Postgres running on the same machine). With some tweaks we were able to get the number of series to half a million, flushing ~60K data points per second.
Now the long version&hellip; If you were to ask me whether Tgres could outperform Graphite, just a couple of months ago my answer would have been &ldquo;No&rdquo;. Tgres uses Postgres to store time series data, while Graphite stores data by writing to files directly, the overhead of the relational database just seemed too great.
" />






<meta name="generator" content="Hugo 0.146.0 with theme even" />


<link rel="canonical" href="https://grisha.org/blog/2017/02/23/can-tgres-outperform-graphite/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">

<link rel="stylesheet" href="/css/custom.css">


<meta property="og:url" content="https://grisha.org/blog/2017/02/23/can-tgres-outperform-graphite/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="PostgreSQL vs Whisper, which is Faster?">
  <meta property="og:description" content="Note: there is an update to this post.
TL;DR On a 8 CPU / 16 GB EC2 instance, Tgres can process 150,000 data points per second across 300,000 series (Postgres running on the same machine). With some tweaks we were able to get the number of series to half a million, flushing ~60K data points per second.
Now the long version… If you were to ask me whether Tgres could outperform Graphite, just a couple of months ago my answer would have been “No”. Tgres uses Postgres to store time series data, while Graphite stores data by writing to files directly, the overhead of the relational database just seemed too great.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2017-02-23T09:49:00+00:00">
    <meta property="article:modified_time" content="2017-02-23T09:49:00+00:00">

  <meta itemprop="name" content="PostgreSQL vs Whisper, which is Faster?">
  <meta itemprop="description" content="Note: there is an update to this post.
TL;DR On a 8 CPU / 16 GB EC2 instance, Tgres can process 150,000 data points per second across 300,000 series (Postgres running on the same machine). With some tweaks we were able to get the number of series to half a million, flushing ~60K data points per second.
Now the long version… If you were to ask me whether Tgres could outperform Graphite, just a couple of months ago my answer would have been “No”. Tgres uses Postgres to store time series data, while Graphite stores data by writing to files directly, the overhead of the relational database just seemed too great.">
  <meta itemprop="datePublished" content="2017-02-23T09:49:00+00:00">
  <meta itemprop="dateModified" content="2017-02-23T09:49:00+00:00">
  <meta itemprop="wordCount" content="1962">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="PostgreSQL vs Whisper, which is Faster?">
  <meta name="twitter:description" content="Note: there is an update to this post.
TL;DR On a 8 CPU / 16 GB EC2 instance, Tgres can process 150,000 data points per second across 300,000 series (Postgres running on the same machine). With some tweaks we were able to get the number of series to half a million, flushing ~60K data points per second.
Now the long version… If you were to ask me whether Tgres could outperform Graphite, just a couple of months ago my answer would have been “No”. Tgres uses Postgres to store time series data, while Graphite stores data by writing to files directly, the overhead of the relational database just seemed too great.">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Gregory Trubetskoy</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/posts/">
        <li class="mobile-menu-item">Archives</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Gregory Trubetskoy</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/posts/">Archives</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">PostgreSQL vs Whisper, which is Faster?</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-02-23 </span>
        
        
      </div>
    </header>

    
    <div class="post-content">
      <p>Note: there is an <a href="/blog/2017/02/28/tgres-load-testing-follow-up/">update</a> to this post.</p>
<h2 id="tldr">TL;DR</h2>
<p>On a 8 CPU / 16 GB EC2 instance,
<a href="https://github.com/tgres/tgres">Tgres</a> can process 150,000 data
points per second across 300,000 series (Postgres running on the same
machine). With some tweaks we were able to get the number of series to
half a million, flushing ~60K data points per second.</p>
<h2 id="now-the-long-version">Now the long version&hellip;</h2>
<p>If you were to ask me whether Tgres could outperform Graphite, just a
couple of months ago my answer would have been &ldquo;No&rdquo;. Tgres uses
Postgres to store time series data, while Graphite stores data by
writing to files directly, the overhead of the relational database
just seemed too great.</p>
<p>Well, I think I&rsquo;ve managed to prove myself wrong. After re-working
Tgres to use the
<a href="/blog/2017/01/21/storing-time-seris-in-postgresql-optimize-for-write/">write-optimized layout</a>,
I&rsquo;ve run some tests on AWS yielding unexpectedly promising results.</p>
<p>As a benchmark I targeted the excellent <a href="http://obfuscurity.com/2016/08/Benchmarking-Carbon-and-Whisper-on-AWS">blog post</a>
by Jason Dixon describing his AWS Graphite test. My goal was to get to at least half the
level of performance described therein. But it appears the combination of Go, Postgres and some
clever data structuring has been able to beat it, not without breaking
a little sweat, but it has.</p>
<p>My test was conducted on a
<a href="https://aws.amazon.com/ec2/instance-types/">c4.2xlarge</a> instance,
which has 8 cores and 16 GB, using 100GB EBS (which, if I understood it
correctly, comes with 300 IOPS, please comment if I&rsquo;m wrong). The &ldquo;c4&rdquo;
instances are supposed to be some of the highest speed CPU AWS has to
offer, but compare this with the instance used in the Graphite test,
an i2.4xlarge (16 CPU/ 122GB), it had half the CPU cores and nearly
one tenth of the RAM.</p>
<p>Before I go any further, here is the obligatory screenshot, then my
observations and lessons learned in the process, as well as a
screenshot depicting even better performance.</p>
<p><img src="/images/tgres_aws1.png" alt=""></p>
<p>The Tgres version running was <a href="https://github.com/tgres/tgres/tree/1c57cba3fe4cdb0b96bf5054cfd01cb2a41e2bba">this one</a>,
with the config detailed at the bottom of the post.</p>
<p>Postgres was whatever <code>yum install postgresql95-server</code> brings your
way, with the <code>data</code> directory moved to the EBS volume formatted using
ext4 (not that I think it matters). The Postgres config was modified to
allow a 100ms commit delay and to make autovacuum extra aggressive. I
did not increase any memory buffers and left everything else as
is. Specifically, these were the changes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>autovacuum_work_mem = -1
</span></span><span style="display:flex;"><span>synchronous_commit = off
</span></span><span style="display:flex;"><span>commit_delay = 100000
</span></span><span style="display:flex;"><span>autovacuum_max_workers = 10
</span></span><span style="display:flex;"><span>autovacuum_naptime = 1s
</span></span><span style="display:flex;"><span>autovacuum_vacuum_threshold = 2000
</span></span><span style="display:flex;"><span>autovacuum_vacuum_scale_factor = 0.0
</span></span><span style="display:flex;"><span>autovacuum_vacuum_cost_delay = 0
</span></span></code></pre></div><p>The data points for the test were generated by a <a href="https://github.com/tgres/tgres/blob/06a9f5805a934c304b11f44a32792414ceafe6f0/blaster/blaster.go#L55">goroutine</a>
in the Tgres process itself. In the past I&rsquo;ve found that blasting a server
with this many UDP packets can be tricky and hardware/network
intensive. It&rsquo;s also hard to tell when/if they get dropped and why,
etc. Since Go is not known for having problems in its network stack, I
was not too worried about it, I just wanted a reliable and
configurable source of incoming packets, and in Go world writing a
simple goroutine seemed like the right answer.</p>
<h2 id="somewhat-random-notes-and-making-tgres-even-faster">Somewhat Random Notes and Making Tgres Even Faster</h2>
<h3 id="determining-failure">Determining failure</h3>
<p>Determining when we are &ldquo;at capacity&rdquo; is tricky. I&rsquo;ve mostly looked at
two factors (aside from the obvious - running out of memory/disk,
becoming unresponsive, etc): receiver queue size
and Postgres <a href="https://www.keithf4.com/checking-for-postgresql-bloat/">table bloat</a>.</p>
<h4 id="queue-size">Queue size</h4>
<p>Tgres uses &ldquo;elastic channels&rdquo; (so eloquently
<a href="https://github.com/npat-efault/musings/wiki/Elastic-channels">described here</a> by Nick Patavalis)
for incoming data points and to load series from Postgres.  These are
channel-like structures that can grow to arbitrary length only limited
by the memory available. This is done so as to be able to take maximum
advantage of the hardware at hand. If any of those queues starts
growing out of control, we are failing. You can see in the picture
that at about 140K data points per second the receiver queue started
growing, though it did stay steady at this size and never spun out of
control (the actual test was left overnight at this rate just to make
sure).</p>
<h4 id="pg-table-bloat">PG Table Bloat</h4>
<p>Table bloat is a phenomenon affecting Postgres in write-intensive
situations because of its adherence to the <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">MVCC</a>.
It basically means that pages on disk are being updated faster than the autovacuum
process can keep up with them and the table starts growing out of
control.</p>
<p>To monitor for table bloat, I used a simple formula which determined
the approximate size of the table based on the row count (our data is
all floats, which makes it very predictable) and compared it with the
actual size. If the actual size exceeded the estimated size, that&rsquo;s
considered bloat. Bloat is reported in the &ldquo;TS Table Size&rdquo; chart. A
little bloat is fine, and you can see that it stayed in fairly low
percent throughout the test.</p>
<p>In the end, though more research is warranted, it may just turn out
that contrary to every expectation PostgreSQL was <em>not</em> the limiting
factor here. The <code>postmaster</code> processes stayed below 170MB RSS, which
is absolutely remarkable, and Grafana refreshes were very quick even
at peak loads.</p>
<h4 id="memory-consumption">Memory consumption</h4>
<p>Tgres has a slight limitation in that creating a series is
expensive. It needs to check with Postgres and for reasons I don&rsquo;t
want to bore you with it&rsquo;s always a SELECT, optionally followed by an
&ldquo;UPSERT&rdquo;. This takes time, and during the ramp-up period when the
number of series is growing fast and lots of them need to be created,
the Go runtime ends up consuming a lot of memory. You can see that
screenshot image reports 4.69GB. If I were to restart Tgres (which
would cause all existing DS names to be pre-cached) its memory
footprint stayed at about 1.7GB. More work needs to be done to figure
out what accounts for the difference.</p>
<h4 id="data-point-rate-and-number-of-series">Data Point Rate and Number of Series</h4>
<p>The rate of data points that need to be saved to disk is a function of
the number of series and the resolution of the RRAs. To illustrate, if
I have one series at 1 point per second, even if I blast a million
data points per second, still only 1 data point per second needs to be
saved.</p>
<p>There is an important difference between Graphite and Tgres in that
Tgres actually adjusts the final value considering the every data
point value using weighted mean, while Graphite just ignores all
points but the last. So Tgres does a bit more work, which adds up
quickly at 6-figure rates per second.</p>
<p>The Graphite test if I read the chart correctly was able to process
~70K data points per second across 300K series. My test had 300K
series and data points were coming in at over 150K/s. But just out of
curiosity, I tried to push it to its limit.</p>
<p>At 400 series, you can see clear signs of deterioration. You can see
how vcache isn&rsquo;t flushed fast enough leaving gaps at the end of
series. If we stop the data blast, it does eventually catch up,
so long as there is memory for the cache.</p>
<p><img src="/images/tgres_aws1_det.png" alt=""></p>
<p>If you don&rsquo;t catch this condition in time, Tgres will die with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>fatal error: runtime: out of memory
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>runtime stack:
</span></span><span style="display:flex;"><span>runtime.throw<span style="color:#f92672">(</span>0xa33e5a, 0x16<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        /home/grisha/.gvm/gos/go1.8/src/runtime/panic.go:596 +0x95
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><h3 id="segment-width">Segment Width</h3>
<p>There is still one easy performance card we can play here. Segment
width is how many data points are stored in one row, it is also the
limit on how many points we can transfer in a single SQL operation.
Segment width by default is 200, because a width higher than that
causes rows to exceed a page and trigger
<a href="https://www.postgresql.org/docs/current/static/storage-toast.html">TOAST</a>.
TOAST can be good or bad because it means data is stored in a separate table
(not so good), but it also means it&rsquo;s compressed, which may be an I/O
win.</p>
<h4 id="so-what-would-happen-if-we-set-the-segment-width-to-1000">So what would happen if we set the segment width to 1000?</h4>
<p>The picture changes significantly (see below). I was able to get the
number of series to 500K, note the whopping 52,602 data points being
written to the database per second! You can see we&rsquo;re pushing it to
the limit because the receiver queue is beginning to grow. I <em>really</em>
wanted to get the rate up to 150K/sec, but it just didn&rsquo;t want to go
there.</p>
<p><img src="/images/tgres_aws1_1k.png" alt=""></p>
<h4 id="and-what-would-happen-if-we-set-the-segment-width-to-4096">And what would happen if we set the segment width to 4096?</h4>
<p>Interestingly, the memory footprint is a tad larger while the vcache
is leaner, the number of data points flushed per second is about same,
though in fewer SQL statements, and the overall picture is about the
same and the incoming queue still skyrockets at just about 100K/sec
over 500K series.</p>
<p><img src="/images/tgres_aws1_4k.png" alt=""></p>
<h2 id="conclusion">Conclusion</h2>
<p>There is plenty of places in Tgres code that could still be
optimized.</p>
<p>One issue that would be worth looking into is exposing Tgres to the
firehose on an empty database. The current code runs out of memory in
under a minute when suddenly exposed to 300K new series at
150K/s. Probably the simplest solution to this would be to somehow
detect that we&rsquo;ve unable to keep up and start dropping data
points. Eventually, when all the series are created and cached,
performance should even out after the initial spike and all should be
well.</p>
<p>In any event, it&rsquo;s nice to be able to do something like this and know
that it is performant as well:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>tgres<span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">select</span> t, r <span style="color:#66d9ef">from</span> ds
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">join</span> tv  <span style="color:#66d9ef">on</span> tv.ds_id <span style="color:#f92672">=</span> ds.id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span> ident <span style="color:#f92672">@&gt;</span> <span style="color:#e6db74">&#39;{&#34;name&#34;:&#34;tgres.0_0_0_0.runtime.load.five&#34;}&#39;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">and</span> tv.step_ms <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> t <span style="color:#66d9ef">desc</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>           t            <span style="color:#f92672">|</span>       r
</span></span><span style="display:flex;"><span><span style="color:#75715e">------------------------+----------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#ae81ff">2017</span><span style="color:#f92672">-</span><span style="color:#ae81ff">02</span><span style="color:#f92672">-</span><span style="color:#ae81ff">23</span> <span style="color:#ae81ff">22</span>:<span style="color:#ae81ff">31</span>:<span style="color:#ae81ff">50</span><span style="color:#f92672">+</span><span style="color:#ae81ff">00</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span>.<span style="color:#ae81ff">256833462648</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">2017</span><span style="color:#f92672">-</span><span style="color:#ae81ff">02</span><span style="color:#f92672">-</span><span style="color:#ae81ff">23</span> <span style="color:#ae81ff">22</span>:<span style="color:#ae81ff">26</span>:<span style="color:#ae81ff">30</span><span style="color:#f92672">+</span><span style="color:#ae81ff">00</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span>.<span style="color:#ae81ff">305209492142</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">2017</span><span style="color:#f92672">-</span><span style="color:#ae81ff">02</span><span style="color:#f92672">-</span><span style="color:#ae81ff">23</span> <span style="color:#ae81ff">22</span>:<span style="color:#ae81ff">24</span>:<span style="color:#ae81ff">10</span><span style="color:#f92672">+</span><span style="color:#ae81ff">00</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span>.<span style="color:#ae81ff">554056287975</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">2017</span><span style="color:#f92672">-</span><span style="color:#ae81ff">02</span><span style="color:#f92672">-</span><span style="color:#ae81ff">23</span> <span style="color:#ae81ff">22</span>:<span style="color:#ae81ff">24</span>:<span style="color:#ae81ff">00</span><span style="color:#f92672">+</span><span style="color:#ae81ff">00</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span>.<span style="color:#ae81ff">453365774931</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">2017</span><span style="color:#f92672">-</span><span style="color:#ae81ff">02</span><span style="color:#f92672">-</span><span style="color:#ae81ff">23</span> <span style="color:#ae81ff">22</span>:<span style="color:#ae81ff">23</span>:<span style="color:#ae81ff">50</span><span style="color:#f92672">+</span><span style="color:#ae81ff">00</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span>.<span style="color:#ae81ff">380504724386</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">5</span> <span style="color:#66d9ef">rows</span>)
</span></span></code></pre></div><h2 id="reference">Reference</h2>
<p>For completness sake, the instance was created using Terraform config
approximately like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">variable</span> <span style="color:#e6db74">&#34;aws_region&#34;</span> { <span style="color:#66d9ef">default</span> = <span style="color:#e6db74">&#34;us-east-1&#34;</span> }
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">variable</span> <span style="color:#e6db74">&#34;aws_zone&#34;</span> { <span style="color:#66d9ef">default</span> = <span style="color:#e6db74">&#34;us-east-1a&#34;</span> }
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">variable</span> <span style="color:#e6db74">&#34;key_name&#34;</span> { <span style="color:#66d9ef">default</span> = <span style="color:#e6db74">&#34;REDACTED&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">provider</span> <span style="color:#e6db74">&#34;aws&#34;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">region</span> = <span style="color:#e6db74">&#34;${var.aws_region}&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">resource</span> <span style="color:#e6db74">&#34;aws_ebs_volume&#34;</span> <span style="color:#e6db74">&#34;ebs_volume&#34;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">availability_zone</span> = <span style="color:#e6db74">&#34;${var.aws_zone}&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">size</span> = <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">resource</span> <span style="color:#e6db74">&#34;aws_volume_attachment&#34;</span> <span style="color:#e6db74">&#34;ebs_att&#34;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">device_name</span> = <span style="color:#e6db74">&#34;/dev/sdh&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">volume_id</span> = <span style="color:#e6db74">&#34;${aws_ebs_volume.ebs_volume.id}&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">instance_id</span> = <span style="color:#e6db74">&#34;${aws_instance.tgres-test-tmp.id}&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">resource</span> <span style="color:#e6db74">&#34;aws_instance&#34;</span> <span style="color:#e6db74">&#34;tgres-test-tmp&#34;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ami</span> = <span style="color:#e6db74">&#34;ami-0b33d91d&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">instance_type</span> = <span style="color:#e6db74">&#34;c4.2xlarge&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">subnet_id</span> = <span style="color:#e6db74">&#34;REDACTED&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">vpc_security_group_ids</span> = [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;REDACTED&#34;</span>
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">associate_public_ip_address</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">key_name</span> = <span style="color:#e6db74">&#34;${var.key_name}&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And then the following commands were used to prime everyting:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo mke2fs /dev/sdh
</span></span><span style="display:flex;"><span>sudo mkdir /ebs
</span></span><span style="display:flex;"><span>sudo mount /dev/sdh /ebs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo yum install -y postgresql95-server
</span></span><span style="display:flex;"><span>sudo service postgresql95 initdb
</span></span><span style="display:flex;"><span>sudo mkdir /ebs/pg
</span></span><span style="display:flex;"><span>sudo mv /var/lib/pgsql95/data /ebs/pg/data
</span></span><span style="display:flex;"><span>sudo ln -s /ebs/pg/data /var/lib/pgsql95/data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo vi /var/lib/pgsql95/data/postgresql.conf
</span></span><span style="display:flex;"><span><span style="color:#75715e"># BEGIN postgres config - paste this somewhere in the file</span>
</span></span><span style="display:flex;"><span>autovacuum_work_mem <span style="color:#f92672">=</span> -1
</span></span><span style="display:flex;"><span>synchronous_commit <span style="color:#f92672">=</span> off
</span></span><span style="display:flex;"><span>commit_delay <span style="color:#f92672">=</span> <span style="color:#ae81ff">100000</span>
</span></span><span style="display:flex;"><span>autovacuum_max_workers <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>autovacuum_naptime <span style="color:#f92672">=</span> 1s
</span></span><span style="display:flex;"><span>autovacuum_vacuum_threshold <span style="color:#f92672">=</span> <span style="color:#ae81ff">2000</span>
</span></span><span style="display:flex;"><span>autovacuum_vacuum_scale_factor <span style="color:#f92672">=</span> 0.0
</span></span><span style="display:flex;"><span>autovacuum_vacuum_cost_delay <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># END postgres config</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo service postgresql95 restart
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># create PG database</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo su - postgres
</span></span><span style="display:flex;"><span>createuser -s ec2-user   <span style="color:#75715e"># note -s is superuser - not necessary for tgres but just in case</span>
</span></span><span style="display:flex;"><span>createdb tgres
</span></span><span style="display:flex;"><span>exit
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Tgres (requires Go - I used 1.8)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># (or you can just scp it from some machine where you already have go environment)</span>
</span></span><span style="display:flex;"><span>mkdir golang
</span></span><span style="display:flex;"><span>export GOPATH<span style="color:#f92672">=</span>~/golang/
</span></span><span style="display:flex;"><span>go get github.com/tgres/tgres
</span></span><span style="display:flex;"><span>cd /home/ec2-user/golang/src/github.com/tgres/tgres
</span></span><span style="display:flex;"><span>go build
</span></span><span style="display:flex;"><span>cp etc/tgres.conf.sample etc/tgres.conf
</span></span></code></pre></div><p>The <code>tgres.conf</code> file looked like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>min-step                <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;10s&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pid-file <span style="color:#f92672">=</span>                 <span style="color:#e6db74">&#34;tgres.pid&#34;</span>
</span></span><span style="display:flex;"><span>log-file <span style="color:#f92672">=</span>                 <span style="color:#e6db74">&#34;log/tgres.log&#34;</span>
</span></span><span style="display:flex;"><span>log-cycle-interval <span style="color:#f92672">=</span>       <span style="color:#e6db74">&#34;24h&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>max-flushes-per-second      <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span> <span style="color:#75715e"># NB - Deprecated setting</span>
</span></span><span style="display:flex;"><span>workers                     <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>       <span style="color:#75715e"># NB - Deprecated setting</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>http-listen-spec            <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0.0.0.0:8888&#34;</span>
</span></span><span style="display:flex;"><span>graphite-line-listen-spec   <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0.0.0.0:2003&#34;</span>
</span></span><span style="display:flex;"><span>graphite-text-listen-spec   <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0.0.0.0:2003&#34;</span>
</span></span><span style="display:flex;"><span>graphite-udp-listen-spec    <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0.0.0.0:2003&#34;</span>
</span></span><span style="display:flex;"><span>graphite-pickle-listen-spec <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0.0.0.0:2004&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>statsd-text-listen-spec     <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0.0.0.0:8125&#34;</span>
</span></span><span style="display:flex;"><span>statsd-udp-listen-spec      <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0.0.0.0:8125&#34;</span>
</span></span><span style="display:flex;"><span>stat-flush-interval         <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;10s&#34;</span>
</span></span><span style="display:flex;"><span>stats-name-prefix           <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;stats&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db-connect-string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;host=/tmp dbname=tgres sslmode=disable&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[[</span>ds<span style="color:#f92672">]]</span>
</span></span><span style="display:flex;"><span>regexp <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;.*&#34;</span>
</span></span><span style="display:flex;"><span>step <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;10s&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#heartbeat = &#34;2h&#34;</span>
</span></span><span style="display:flex;"><span>rras <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;10s:6h&#34;</span>, <span style="color:#e6db74">&#34;1m:7d&#34;</span>, <span style="color:#e6db74">&#34;1h:1y&#34;</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>Tgres was running with the following. The <code>TGRES_BLASTER</code> starts the
blaster goroutine.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>TGRES_BIND<span style="color:#f92672">=</span>0.0.0.0 TGRES_BLASTER<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> ./tgres
</span></span></code></pre></div><p>Once you have Tgres with the blaster running, you can control it via
HTTP, e.g. the following would set it to 50K/s data points across 100K
series. Setting rate to 0 pauses it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl -v <span style="color:#e6db74">&#34;http://127.0.0.1:8888/blaster/set?rate=50000&amp;n=100000&#34;</span>
</span></span></code></pre></div>
    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/blog/2017/02/28/tgres-load-testing-follow-up/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Tgres Load Testing Follow Up</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/blog/2017/01/21/storing-time-seris-in-postgresql-optimize-for-write/">
            <span class="next-text nav-default">Storing Time Series in PostgreSQL - Optimize for Write</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'grisha';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2013 - 
    2026<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
