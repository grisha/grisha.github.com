<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Bitcoin Transaction Hash in Pure PostgreSQL - Gregory Trubetskoy</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="Update: hacked together this, more details to follow later&hellip;
In theory, Postgres should be able to verify transactions and blocks, as well as do a lot of other things that are currently only done by full nodes. For this to be performant, it will most likely require an extension written in C, but I&rsquo;m curious how far we can get with bare bones Postgres.
More importantly, would that actually be useful? A node is really just a database, a very efficient one for a very specific purpose, but would leveraging the full power of Postgres be somehow more beneficial than just running Bitcoin-Qt or btcd, for example?
" />






<meta name="generator" content="Hugo 0.146.0 with theme even" />


<link rel="canonical" href="https://grisha.org/blog/2017/10/10/postgre-as-a-full-node/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">

<link rel="stylesheet" href="/css/custom.css">


<meta property="og:url" content="https://grisha.org/blog/2017/10/10/postgre-as-a-full-node/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="Bitcoin Transaction Hash in Pure PostgreSQL">
  <meta property="og:description" content="Update: hacked together this, more details to follow later…
In theory, Postgres should be able to verify transactions and blocks, as well as do a lot of other things that are currently only done by full nodes. For this to be performant, it will most likely require an extension written in C, but I’m curious how far we can get with bare bones Postgres.
More importantly, would that actually be useful? A node is really just a database, a very efficient one for a very specific purpose, but would leveraging the full power of Postgres be somehow more beneficial than just running Bitcoin-Qt or btcd, for example?">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2017-10-10T17:54:00+00:00">
    <meta property="article:modified_time" content="2017-10-10T17:54:00+00:00">

  <meta itemprop="name" content="Bitcoin Transaction Hash in Pure PostgreSQL">
  <meta itemprop="description" content="Update: hacked together this, more details to follow later…
In theory, Postgres should be able to verify transactions and blocks, as well as do a lot of other things that are currently only done by full nodes. For this to be performant, it will most likely require an extension written in C, but I’m curious how far we can get with bare bones Postgres.
More importantly, would that actually be useful? A node is really just a database, a very efficient one for a very specific purpose, but would leveraging the full power of Postgres be somehow more beneficial than just running Bitcoin-Qt or btcd, for example?">
  <meta itemprop="datePublished" content="2017-10-10T17:54:00+00:00">
  <meta itemprop="dateModified" content="2017-10-10T17:54:00+00:00">
  <meta itemprop="wordCount" content="1209">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Bitcoin Transaction Hash in Pure PostgreSQL">
  <meta name="twitter:description" content="Update: hacked together this, more details to follow later…
In theory, Postgres should be able to verify transactions and blocks, as well as do a lot of other things that are currently only done by full nodes. For this to be performant, it will most likely require an extension written in C, but I’m curious how far we can get with bare bones Postgres.
More importantly, would that actually be useful? A node is really just a database, a very efficient one for a very specific purpose, but would leveraging the full power of Postgres be somehow more beneficial than just running Bitcoin-Qt or btcd, for example?">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Gregory Trubetskoy</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/posts/">
        <li class="mobile-menu-item">Archives</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Gregory Trubetskoy</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/posts/">Archives</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Bitcoin Transaction Hash in Pure PostgreSQL</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-10-10 </span>
        
        
      </div>
    </header>

    
    <div class="post-content">
      <p>Update: hacked together
<a href="https://github.com/blkchain/pg_blkchain">this</a>, more details to
follow later&hellip;</p>
<p>In theory, Postgres should be able to verify transactions and blocks,
as well as do a lot of other things that are currently only done by
full nodes. For this to be performant, it will most likely require an
extension written in C, but I&rsquo;m curious how far we can get with bare
bones Postgres.</p>
<p>More importantly, would that actually be useful? A node is really
just a database, a very efficient one for a very specific purpose, but
would leveraging the full power of Postgres be somehow more beneficial
than just running Bitcoin-Qt or btcd, for example?</p>
<p>To get to the bottom of this would be a lot of work, and potentially a
lot of fun. It would also be a great blockchain learning exercise. (If
you&rsquo;re working on a PG extension for Bitcoin or more generally
blockchain, please do let me know!)</p>
<h3 id="random-thoughts">Random Thoughts</h3>
<p>The structure of the Bitcoin blockchain is relatively simple.  We have
<em>transactions</em>, which in turn have <em>inputs</em> and <em>outputs</em> and belong
to <em>blocks</em>. Four tables, that&rsquo;s it.</p>
<p>I&rsquo;ve been able to import the whole blockchain with some fairly basic
Go code into my old Thinkpad running Linux overnight. The Go code
needs some more polishing and is probably worthy of a separate write
up, so I won&rsquo;t get into it for now. Below is the schema I used. I
intentionally left out referential integrity and indexes to keep it
simple and avoid premature optimization.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> blocks (                     <span style="color:#75715e">-- CBlockIndex (chain.h)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   id           BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,prev         BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>              <span style="color:#75715e">-- .prev-&gt;nHeight  // genesis will have -1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ,height       BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>              <span style="color:#75715e">-- .nHeight
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ,hash         BYTEA <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>            <span style="color:#75715e">-- &lt;computed&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ,<span style="color:#66d9ef">version</span>      BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>              <span style="color:#75715e">-- .nVersion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ,prevhash     BYTEA <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>            <span style="color:#75715e">-- .pprev-&gt;GetBlockHash()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ,merkleroot   BYTEA <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>            <span style="color:#75715e">-- .hashMerkleRoot
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ,time         BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>           <span style="color:#75715e">-- .nTime
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ,bits         BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>           <span style="color:#75715e">-- .nBits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ,nonce        BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>           <span style="color:#75715e">-- .nNonce
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> txs (
</span></span><span style="display:flex;"><span>   id            BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,txid          BYTEA <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,<span style="color:#66d9ef">version</span>       BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,locktime      BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> txins (
</span></span><span style="display:flex;"><span>   id            BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,tx_id         BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,n             BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,prevout_hash  BYTEA <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,prevout_n     BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,scriptsig     BYTEA <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,sequence      BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> txouts (
</span></span><span style="display:flex;"><span>   id           BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,tx_id        BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,n            BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,value        BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>  ,scriptpubkey BYTEA <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>There are a couple projects out there that keep the blockchain in a
database, most notably
<a href="https://github.com/bitcoin-abe/bitcoin-abe">Abe</a>. I haven&rsquo;t studied
the code very carefully, but my initial impression was that Abe tries
to use standard SQL that would work across most big databases, which
is philosophically different from my objective of going 100% Postgres
and leveraging all that it can do for us.</p>
<p>Bitcoin uses a lot of uint32&rsquo;s. A Postgres INT is the correct size,
but it is signed, which means we have to use the next larger type,
BIGINT. It seems like it might be a waste to use 64 bits for a 32-bit
value, but I couldn&rsquo;t think of anything better than a BIGINT. For the
binary stuff it seems like BYTEA is the best match.</p>
<p>So what can we do with this? There is no easy way to create or verify an
<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">Elliptic Curve signature</a>
in Postgres, but with the help of the <a href="https://www.postgresql.org/docs/current/static/pgcrypto.html">pgcrypto</a>
extension, we should be able to at least generate the correct SHA256
digest which is used in the signature. As a side note, EC signature math is actually
remarkably simple and could probably be implemented
as a PG function, but I&rsquo;m too lazy. Here it is in a
<a href="https://github.com/wobine/blackboard101/blob/master/EllipticCurvesPart5-TheMagic-SigningAndVerifying.py">few lines of Python</a>.</p>
<p>The rules on how Bitcoin generates the hash (which is then signed) are
slightly <a href="https://en.bitcoin.it/w/images/en/7/70/Bitcoin_OpCheckSig_InDetail.png">complicated</a>, and that&rsquo;s an
<a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html">understatement</a>.</p>
<p>For the purposes of this exercise, I&rsquo;d just be happy with a value that
matches, even if the code does not fully comply with the Bitcoin rules.</p>
<p>One problem I ran into was that, because Bitcoin blockchain is
little-endian except for where it isn&rsquo;t, you often need a way to
reverse bytes in a BYTEA. Strangely, Postgres does not provide a way
to do that, unless I&rsquo;m missing something. But thanks to
<a href="https://stackoverflow.com/questions/11142235/convert-bigint-to-bytea-but-swap-the-byte-order">stackoverflow</a>,
here is one way to do this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">OR</span> <span style="color:#66d9ef">REPLACE</span> <span style="color:#66d9ef">FUNCTION</span> reverse(bytea) <span style="color:#66d9ef">RETURNS</span> bytea <span style="color:#66d9ef">AS</span> <span style="color:#960050;background-color:#1e0010">$</span>reverse$
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SELECT</span> string_agg(byte,<span style="color:#e6db74">&#39;&#39;</span>::bytea)
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">FROM</span> (
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">SELECT</span> substr(<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">1</span>,i,<span style="color:#ae81ff">1</span>) byte
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">FROM</span> generate_series(<span style="color:#66d9ef">length</span>(<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">1</span>),<span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) i) s
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">$</span>reverse$ <span style="color:#66d9ef">LANGUAGE</span> <span style="color:#66d9ef">sql</span>;
</span></span></code></pre></div><p>We also have no way to render a Bitcoin
<a href="https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer">varint</a>, but we can fake it
with some substringing for the time being.</p>
<p>Equipped with this, we can construct the following statement, sorry
it&rsquo;s a little long and I do not have the patience to explain it in
writing.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> digest(digest(tx_ser <span style="color:#f92672">||</span> hashtype, <span style="color:#e6db74">&#39;sha256&#39;</span>), <span style="color:#e6db74">&#39;sha256&#39;</span>) <span style="color:#66d9ef">as</span> shasha <span style="color:#66d9ef">from</span> (
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">substring</span>(reverse(int8send(<span style="color:#66d9ef">version</span>)) <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>       vin <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>       vout <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">substring</span>(reverse(int8send(locktime)) <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">4</span>) <span style="color:#66d9ef">AS</span> tx_ser,
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">substring</span>(reverse(int8send(<span style="color:#ae81ff">1</span>)) <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">4</span>) <span style="color:#66d9ef">AS</span> hashtype
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">from</span> txs t
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">join</span> txins tt <span style="color:#66d9ef">ON</span> tt.tx_id <span style="color:#f92672">=</span> t.id
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">join</span> <span style="color:#66d9ef">lateral</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">select</span> tx_id, <span style="color:#66d9ef">substring</span>(reverse(int8send(<span style="color:#66d9ef">count</span>(<span style="color:#ae81ff">1</span>))) <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span> string_agg(txin_ser, <span style="color:#e6db74">&#39;&#39;</span>) <span style="color:#66d9ef">as</span> vin
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">from</span> (
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">select</span>
</span></span><span style="display:flex;"><span>         ti.tx_id,
</span></span><span style="display:flex;"><span>         reverse(prevout_hash) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">substring</span>(reverse(int8send(prevout_n)) <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">substring</span>(reverse(int8send(<span style="color:#66d9ef">length</span>(<span style="color:#66d9ef">CASE</span> <span style="color:#66d9ef">WHEN</span> ti.n <span style="color:#f92672">=</span> tt.n <span style="color:#66d9ef">THEN</span> ptxout.scriptpubkey <span style="color:#66d9ef">ELSE</span> <span style="color:#e6db74">&#39;&#39;</span> <span style="color:#66d9ef">END</span>))) <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">CASE</span> <span style="color:#66d9ef">WHEN</span> ti.n <span style="color:#f92672">=</span> tt.n <span style="color:#66d9ef">THEN</span> ptxout.scriptpubkey <span style="color:#66d9ef">ELSE</span> <span style="color:#e6db74">&#39;&#39;</span> <span style="color:#66d9ef">END</span> <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">substring</span>(reverse(int8send(sequence)) <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">4</span>) <span style="color:#66d9ef">as</span> txin_ser
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">from</span> txins ti
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">join</span> txs ptx <span style="color:#66d9ef">on</span> ti.prevout_hash <span style="color:#f92672">=</span> ptx.txid
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">join</span> txouts ptxout <span style="color:#66d9ef">on</span> ptxout.tx_id <span style="color:#f92672">=</span> ptx.id <span style="color:#66d9ef">and</span> ti.prevout_n <span style="color:#f92672">=</span> ptxout.n
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> ti.n
</span></span><span style="display:flex;"><span>     ) x
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> tx_id
</span></span><span style="display:flex;"><span>   ) vin <span style="color:#66d9ef">on</span> vin.tx_id <span style="color:#f92672">=</span> tt.tx_id
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">join</span> (
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">select</span> tx_id, <span style="color:#66d9ef">substring</span>(reverse(int8send(<span style="color:#66d9ef">count</span>(<span style="color:#ae81ff">1</span>))) <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span> string_agg(txout_ser, <span style="color:#e6db74">&#39;&#39;</span>) <span style="color:#66d9ef">as</span> vout
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">from</span> (
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">select</span>
</span></span><span style="display:flex;"><span>          tx_id,
</span></span><span style="display:flex;"><span>          reverse(int8send(value)) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">substring</span>(reverse(int8send(<span style="color:#66d9ef">length</span>(scriptpubkey))) <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>          scriptpubkey <span style="color:#66d9ef">as</span> txout_ser
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">from</span> txouts
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> n
</span></span><span style="display:flex;"><span>        ) x
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> tx_id
</span></span><span style="display:flex;"><span>    ) <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">out</span>.tx_id <span style="color:#f92672">=</span> tt.tx_id
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">where</span> tt.tx_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">37898</span>
</span></span><span style="display:flex;"><span>) x;
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span>[ RECORD <span style="color:#ae81ff">1</span> ]<span style="color:#75715e">--------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>shasha <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">\</span>x23c3bf5091f3cdaf5996b0091c5f5bb6d82f3cdc2ce077018bb854f40274e512
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span>[ RECORD <span style="color:#ae81ff">2</span> ]<span style="color:#75715e">--------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>shasha <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">\</span>xbcd4d519931da3ab98ca9745a0ceba79f05306cad4fa6ee9863819d1783a2e00
</span></span></code></pre></div><p>The particular transaction we are looking at is
<a href="https://blockchain.info/tx/2847ae66175042438532c2eccc5b39935fd1216453e62e2c3cb9c8e5020cc771">this</a>.
It happens to have id of 37898 in my database. In case you&rsquo;re
wondering, for this example I used a subset of the blockchain which
only has the first 182,000 blocks. On the full blockchain and without
indexes, this statement would have taken an eternity to execute.</p>
<p>What makes this particular transaction interesting is that it has two
inputs, which is slightly trickier, because to spend them, there need to
be two different signatures of the same transaction. This is because
before signing, the input scriptSig needs to be replaced with the
output&rsquo;s scriptPubKey (the oversimplified version). This is reflected in the SQL
in the use of <code>LATERAL</code> and <code>CASE</code>.</p>
<p>You do not have to take my word that the two hashes are correct, we
can verify them fairly easily with a bit of help from the Python ecdsa
library. Here is the code to verify the second hash. The key and the
signature are in the
<a href="https://blockchain.info/tx/2847ae66175042438532c2eccc5b39935fd1216453e62e2c3cb9c8e5020cc771">transaction itself</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> ecdsa
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> codecs
</span></span><span style="display:flex;"><span>key <span style="color:#f92672">=</span> codecs<span style="color:#f92672">.</span>decode(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;04de99a4267263f495e07721f96241359b48b9f522973b9d333ed8e296357c595130535ca387601955f1406e335cf658bb6a12d62c177e9511498fefcafead1c0e&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;hex&#34;</span>)
</span></span><span style="display:flex;"><span>der <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0V0</span><span style="color:#ae81ff">\x10\x06\x07</span><span style="color:#e6db74">*</span><span style="color:#ae81ff">\x86</span><span style="color:#e6db74">H</span><span style="color:#ae81ff">\xce</span><span style="color:#e6db74">=</span><span style="color:#ae81ff">\x02\x01\x06\x05</span><span style="color:#e6db74">+</span><span style="color:#ae81ff">\x81\x04\x00\n\x03</span><span style="color:#e6db74">B</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">+</span> key
</span></span><span style="display:flex;"><span>digest <span style="color:#f92672">=</span> codecs<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#34;bcd4d519931da3ab98ca9745a0ceba79f05306cad4fa6ee9863819d1783a2e00&#34;</span>, <span style="color:#e6db74">&#34;hex&#34;</span>)
</span></span><span style="display:flex;"><span>signature <span style="color:#f92672">=</span> codecs<span style="color:#f92672">.</span>decode(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;30460221008e95fd3536cfd437c49e4c1dfaeeb2ece0e521420c89f1487ca6eff94053485c022100ef3a8cdc9b0a6d6d403bf7758c6b617380db6936de2bbcd3b556ec5f45c03b54&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;hex&#34;</span>)
</span></span><span style="display:flex;"><span>vk <span style="color:#f92672">=</span> ecdsa<span style="color:#f92672">.</span>VerifyingKey<span style="color:#f92672">.</span>from_der(der)
</span></span><span style="display:flex;"><span>print vk<span style="color:#f92672">.</span>verify_digest(signature, digest, sigdecode<span style="color:#f92672">=</span>ecdsa<span style="color:#f92672">.</span>util<span style="color:#f92672">.</span>sigdecode_der)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># True</span>
</span></span></code></pre></div><p>I hope this was fun! Now I wonder how hard it would be to make an
extension to provide all the functionality required by Bitcoin&hellip;.</p>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/blog/2017/10/20/blockchain-in-postgresql-part-2/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Blockchain in PostgreSQL Part 2</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/blog/2017/09/28/electricity-cost-of-1-bitcoin/">
            <span class="next-text nav-default">Electricity cost of 1 Bitcoin (Sep 2017)</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'grisha';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2013 - 
    2026<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
