<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Relational database on top of key-value store explained (or why B-trees are cool) - Gregory Trubetskoy</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="This post attempts to explain how a relational database can be implemented atop a key/value store, a subject that I&rsquo;ve long found rather mysterious.
Every once in a while I would come across a mention that a relational database can be implemented using a key/value store (aka dictionary, hash table or hash map - for brevity I&rsquo;ll be using map from here on).
Whenever I thought about it, it just didn&rsquo;t make sense. A relational database needs to store rows in order, and that&rsquo;s one feature that maps do not provide. Imagine we have a table keyed by employee id stored in a map and we need to traverse it by id in ascending order. A hypothetical keys() method would return us a list of ids ordered randomly. It&rsquo;s impossible to iterate over a hash map in order. So how would a relational database work then?
" />






<meta name="generator" content="Hugo 0.146.0 with theme even" />


<link rel="canonical" href="https://grisha.org/blog/2013/05/11/relational-database-on-top-of-key-value-store-explained/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">

<link rel="stylesheet" href="/css/custom.css">


<meta property="og:url" content="https://grisha.org/blog/2013/05/11/relational-database-on-top-of-key-value-store-explained/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="Relational database on top of key-value store explained (or why B-trees are cool)">
  <meta property="og:description" content="This post attempts to explain how a relational database can be implemented atop a key/value store, a subject that I’ve long found rather mysterious.
Every once in a while I would come across a mention that a relational database can be implemented using a key/value store (aka dictionary, hash table or hash map - for brevity I’ll be using map from here on).
Whenever I thought about it, it just didn’t make sense. A relational database needs to store rows in order, and that’s one feature that maps do not provide. Imagine we have a table keyed by employee id stored in a map and we need to traverse it by id in ascending order. A hypothetical keys() method would return us a list of ids ordered randomly. It’s impossible to iterate over a hash map in order. So how would a relational database work then?">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2013-05-11T11:36:00+00:00">
    <meta property="article:modified_time" content="2013-05-11T11:36:00+00:00">

  <meta itemprop="name" content="Relational database on top of key-value store explained (or why B-trees are cool)">
  <meta itemprop="description" content="This post attempts to explain how a relational database can be implemented atop a key/value store, a subject that I’ve long found rather mysterious.
Every once in a while I would come across a mention that a relational database can be implemented using a key/value store (aka dictionary, hash table or hash map - for brevity I’ll be using map from here on).
Whenever I thought about it, it just didn’t make sense. A relational database needs to store rows in order, and that’s one feature that maps do not provide. Imagine we have a table keyed by employee id stored in a map and we need to traverse it by id in ascending order. A hypothetical keys() method would return us a list of ids ordered randomly. It’s impossible to iterate over a hash map in order. So how would a relational database work then?">
  <meta itemprop="datePublished" content="2013-05-11T11:36:00+00:00">
  <meta itemprop="dateModified" content="2013-05-11T11:36:00+00:00">
  <meta itemprop="wordCount" content="731">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Relational database on top of key-value store explained (or why B-trees are cool)">
  <meta name="twitter:description" content="This post attempts to explain how a relational database can be implemented atop a key/value store, a subject that I’ve long found rather mysterious.
Every once in a while I would come across a mention that a relational database can be implemented using a key/value store (aka dictionary, hash table or hash map - for brevity I’ll be using map from here on).
Whenever I thought about it, it just didn’t make sense. A relational database needs to store rows in order, and that’s one feature that maps do not provide. Imagine we have a table keyed by employee id stored in a map and we need to traverse it by id in ascending order. A hypothetical keys() method would return us a list of ids ordered randomly. It’s impossible to iterate over a hash map in order. So how would a relational database work then?">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Gregory Trubetskoy</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/posts/">
        <li class="mobile-menu-item">Archives</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Gregory Trubetskoy</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/posts/">Archives</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Relational database on top of key-value store explained (or why B-trees are cool)</h1>

      <div class="post-meta">
        <span class="post-time"> 2013-05-11 </span>
        
        
      </div>
    </header>

    
    <div class="post-content">
      <p>This post attempts to explain how a relational database can be
implemented atop a key/value store, a subject that I&rsquo;ve long found
rather mysterious.</p>
<p>Every once in a while I would come across a mention that a relational
database can be implemented using a key/value store (aka dictionary,
hash table or hash map - for brevity I&rsquo;ll be using <em>map</em> from here on).</p>
<p>Whenever I thought about it, it just didn&rsquo;t make sense. A relational
database needs to store rows <em>in order</em>, and that&rsquo;s one feature that
maps do not provide. Imagine we have a table keyed by employee id
stored in a map and we need to traverse it by id in ascending order. A
hypothetical keys() method would return us a list of ids ordered
randomly. It&rsquo;s impossible to iterate over a hash map <em>in
order</em>. So how would a relational database work then?</p>
<p>It took a while for me to realize the root of my misunderstanding. I
naively was trying to picture how tables, rows and values can be
represented as key/value pairs, and that was the wrong path to take. I
was focusing on the wrong layer of abstraction.</p>
<p>As it turns out the
key [NPI] to this problem is the clever data structure commonly used
to store data in a relational DB known as
<em><a href="http://en.wikipedia.org/wiki/B-tree">B-Tree</a></em> (or a variation
thereof, <em><a href="http://en.wikipedia.org/wiki/B+tree">B+Tree</a></em>).
Okay, B-trees are nothing new and I&rsquo;m sure we&rsquo;ve all heard of them. In fact B-trees were
desgined in the 1970&rsquo;s as a generalization of the
<a href="http://en.wikipedia.org/wiki/Binary_search_tree">Binary Search Tree</a> that was
more suited for block storage.</p>
<p>But there is something about B-trees that I did not know, and which
now that I do know, seems absolutely essential as well as simply brilliant. In his 1979 paper &ldquo;The
Ubiquitous B-Tree&rdquo; <a href="http://www.cs.purdue.edu/people/comer">Douglas Comer</a> writes:</p>
<blockquote> The availability of demand paging hardware suggests an
interesting implementation of B-trees.  Through careful allocation,
each node of the B-tree can be mapped into one page of the virtual
address space.  Then the user treats the B-tree as if it were in
memory.  Accesses to nodes (pages) which are not in memory cause the
system to "page-in" the node from secondary storage. </blockquote>
<p>The above paragraph implies that the B-Tree and all its data can be
stored in <em>pages</em>. In fact, if you look at the file
<a href="http://www.sqlite.org/src/artifact/eecc84f02375b2bb7a44abbcbbe3747dde73edb2">format of a SQLite 3 database</a>
(who says source code comments are bad?) you&rsquo;ll see it states quite plainly  that the <em>file
is divided into pages</em>. (You will also see a fantastic description of exactly
how a B+tree works, but that&rsquo;s way outside the scope of this post.)</p>
<p>The important point is that the entire file consists of pages and
nothing else. Inside those pages live the B-tree structure, as well as
the data. Each table is a B-tree and to access it we need to know the
starting page number, which in turn is stored in the sqlite_master
table whose root page is always the first page of the file. The root
page of a table is the head of the B-tree strucutre, and it may refer
to other pages, which in turn may be additional nodes of the tree or
pure data.</p>
<p>All pages are of the same size and are numbered
sequentially, thus we can easily retreive any page by its number
because its offset into the file is the page number multiplied by the
page size. (By default a SQLite3 page is 1K and will hold 4 keys,
i.e. the order of the tree is 4).</p>
<p>And bingo, there is our key/value pair: the page number is the key,
and the page itself is the value! All you need to do is stick those
pages into your favorite key/value store keyed by page number and
you&rsquo;ve got a relational database atop a key/value store. It&rsquo;s that
simple.</p>
<p>P.S. An astute reader may point out that there is such a thing as a
<em>sorted map</em>. But a sorted map is very different from a &ldquo;pure&rdquo; hash
map. The miracle of hashing is that not only does it let you find
elements in O(1) time, but more importantly that it is very suitable
for distributed processing, where the map may be spread across
multiple servers. And if you start thinking about how a <em>sorted</em> map
might be implemented in a distributed fashion, you will ultimately
loop back to B-trees, because that&rsquo;s typically how it&rsquo;s actually done.</p>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/blog/2013/05/23/checking-out-cloudera-impala/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Checking out Cloudera Impala</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/blog/2013/04/19/mapjoin-a-simple-way-to-speed-up-your-hive-queries/">
            <span class="next-text nav-default">MapJoin: a simple way to speed up your Hive queries</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'grisha';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2013 - 
    2026<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
