<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>How InfluxDB Stores Data | Gregory Trubetskoy</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="A nice, reliable, horizontally scalable database that is designed
specifically to tackle the problem of Time Series data (and does not
require you to stand up a Hadoop cluster) is very much missing from the
Open Source Universe right now.
InfluxDB might be able to fill this gap, it certainly aims to.
I was curious about how it structures and stores data and since there
wasn&rsquo;t much documentation on the subject and I ended up just reading
the code, I figured I&rsquo;d write this up. I only looked at the new
(currently 0.9.0 in RC stage) version, the previous versions are
significantly different.">
    <meta name="generator" content="Hugo 0.146.0">
    
    
    
      <meta name="robots" content="index, follow">
    
    <meta name="author" content="Gregory Trubetskoy">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.d05fb5f317fcf33b3a52936399bdf6f47dc776516e1692e412ec7d76f4a5faa2.css" >




    


    
      

    

    

    
      <link rel="canonical" href="https://grisha.org/blog/2015/03/20/influxdb-data/">
    

    
    
    <meta property="og:url" content="https://grisha.org/blog/2015/03/20/influxdb-data/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="How InfluxDB Stores Data">
  <meta property="og:description" content="A nice, reliable, horizontally scalable database that is designed specifically to tackle the problem of Time Series data (and does not require you to stand up a Hadoop cluster) is very much missing from the Open Source Universe right now.
InfluxDB might be able to fill this gap, it certainly aims to.
I was curious about how it structures and stores data and since there wasn’t much documentation on the subject and I ended up just reading the code, I figured I’d write this up. I only looked at the new (currently 0.9.0 in RC stage) version, the previous versions are significantly different.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2015-03-20T15:52:00+00:00">
    <meta property="article:modified_time" content="2015-03-20T15:52:00+00:00">

  <meta itemprop="name" content="How InfluxDB Stores Data">
  <meta itemprop="description" content="A nice, reliable, horizontally scalable database that is designed specifically to tackle the problem of Time Series data (and does not require you to stand up a Hadoop cluster) is very much missing from the Open Source Universe right now.
InfluxDB might be able to fill this gap, it certainly aims to.
I was curious about how it structures and stores data and since there wasn’t much documentation on the subject and I ended up just reading the code, I figured I’d write this up. I only looked at the new (currently 0.9.0 in RC stage) version, the previous versions are significantly different.">
  <meta itemprop="datePublished" content="2015-03-20T15:52:00+00:00">
  <meta itemprop="dateModified" content="2015-03-20T15:52:00+00:00">
  <meta itemprop="wordCount" content="1286">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="How InfluxDB Stores Data">
  <meta name="twitter:description" content="A nice, reliable, horizontally scalable database that is designed specifically to tackle the problem of Time Series data (and does not require you to stand up a Hadoop cluster) is very much missing from the Open Source Universe right now.
InfluxDB might be able to fill this gap, it certainly aims to.
I was curious about how it structures and stores data and since there wasn’t much documentation on the subject and I ended up just reading the code, I figured I’d write this up. I only looked at the new (currently 0.9.0 in RC stage) version, the previous versions are significantly different.">

      
      
    
	
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$', '$'] ],
      displayMath: [ ['$$', '$$']],
      processEscapes: true,
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  </head><body class="ma0 avenir bg-near-white production">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Gregory Trubetskoy
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/archives/" title="Archives page">
              Archives
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l mw7 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">How InfluxDB Stores Data</h1>
      
      <p class="tracked"><strong>Gregory Trubetskoy</strong>
      </p>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2015-03-20T15:52:00Z">March 20, 2015</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-100-l"><p>A nice, reliable, horizontally scalable database that is designed
specifically to tackle the problem of Time Series data (and does not
require you to stand up a Hadoop cluster) is very much missing from the
Open Source Universe right now.</p>
<p><a href="https://github.com/influxdb/influxdb">InfluxDB</a> might be able to fill this gap, it certainly aims to.</p>
<p>I was curious about how it structures and stores data and since there
wasn&rsquo;t much documentation on the subject and I ended up just reading
the code, I figured I&rsquo;d write this up. I only looked at the new
(currently 0.9.0 in RC stage) version, the previous versions are
significantly different.</p>
<p>First of all, InfluxDB is distributed. You can run one node, or a
bunch, it seems like a more typical number may be 3 or 5. The nodes
use <a href="https://github.com/goraft/raft">Raft</a> to establish consensus and maintain data consistency.</p>
<p>InfluxDB feels a little like a relational database in some aspects
(e.g. it has a SQL-like query language) but not in others.</p>
<p>The top level container is a <em>database</em>. An InfluxDB database is very
much like what a database is in MySQL, it&rsquo;s a collection of other
things.</p>
<p>&ldquo;Other things&rdquo; are called <em>data points</em>, <em>series</em>, <em>measurements</em>,
<em>tags</em> and <em>retention policies</em>. Under the hood (i.e. you never deal
with them directly) there are <em>shards</em> and <em>shard groups</em>.</p>
<p>The very first thing you need to do in InfluxDB is create a database
and at least one retention policy for this database. Once you have
these two things, you can start writing data.</p>
<p>A retention policy is the time period after which the data expires. It
can be set to be infinite. A data point, which is a measurement
consisting of any number of values and tags associated with a
particular point in time, must be associated with a database and a
retention policy. A retention policy also specifies the <em>replication
factor</em> for the data point.</p>
<p>Let&rsquo;s say we are tracking disk usage across a whole bunch of
servers. Each server runs some sort of an agent which periodically
reports the usage of each disk to InfluxDB. Such a report might look
like this (in JSON):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{&#34;database&#34; : &#34;foo&#34;, &#34;retentionPolicy&#34; : &#34;bar&#34;,
</span></span><span style="display:flex;"><span> &#34;points&#34; : [
</span></span><span style="display:flex;"><span>   {&#34;name&#34; : &#34;disk&#34;,
</span></span><span style="display:flex;"><span>    &#34;tags&#34; : {&#34;server&#34; : &#34;bwi23&#34;, &#34;unit&#34; : &#34;1&#34;},
</span></span><span style="display:flex;"><span>    &#34;timestamp&#34; : &#34;2015-03-16T01:02:26.234Z&#34;,
</span></span><span style="display:flex;"><span>    &#34;fields&#34; : {&#34;total&#34; : 100, &#34;used&#34; : 40, &#34;free&#34; : 60}}]}
</span></span></code></pre></div><p>In the above example, &ldquo;disk&rdquo; is a measurement. Thus we can operate on
anything &ldquo;disk&rdquo;, regardless of what &ldquo;server&rdquo; or &ldquo;unit&rdquo; it applies
to. The data point as a whole belongs to a (time) series identified by
the combination of the measurement name and the tags.</p>
<p>There is no need to create series or measurements, they are created on
the fly.</p>
<p>To list the measurements, we can use <code>SHOW MEASUREMENTS</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>&gt; show measurements
</span></span><span style="display:flex;"><span>name            tags    name
</span></span><span style="display:flex;"><span>----            ----    ----
</span></span><span style="display:flex;"><span>measurements            disk
</span></span></code></pre></div><p>We can use <code>SHOW SERIES</code> to list the series:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>&gt; show series
</span></span><span style="display:flex;"><span>name    tags    id      server   unit
</span></span><span style="display:flex;"><span>----    ----    --      -------  ----
</span></span><span style="display:flex;"><span>disk            1       bw123    1
</span></span></code></pre></div><p>If we send a record that contains different tags, we automatically
create a different series (or so it seems), for example if we send
this (note we changed &ldquo;unit&rdquo; to &ldquo;foo&rdquo;):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>{&#34;database&#34; : &#34;foo&#34;, &#34;retentionPolicy&#34; : &#34;bar&#34;,
</span></span><span style="display:flex;"><span> &#34;points&#34; : [
</span></span><span style="display:flex;"><span>   {&#34;name&#34; : &#34;disk&#34;,
</span></span><span style="display:flex;"><span>    &#34;tags&#34; : {&#34;server&#34; : &#34;bwi23&#34;, &#34;foo&#34; : &#34;bar&#34;},
</span></span><span style="display:flex;"><span>    &#34;timestamp&#34; : &#34;2015-03-16T01:02:26.234Z&#34;,
</span></span><span style="display:flex;"><span>    &#34;fields&#34; : {&#34;total&#34; : 100, &#34;used&#34; : 40, &#34;free&#34; : 60}}]}
</span></span></code></pre></div><p>we get</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>&gt; show series
</span></span><span style="display:flex;"><span>name    tags    id      foo     server  unit
</span></span><span style="display:flex;"><span>----    ----    --      ---     ------  ----
</span></span><span style="display:flex;"><span>disk            1               bwi23   1
</span></span><span style="display:flex;"><span>disk            2       bar     bwi23
</span></span></code></pre></div><p>This is where the distinction between measurement and series becomes a
little confusing to me. In actuality (from looking at the code and the
actual files InfluxDB created) there is only one series here called
&ldquo;disk&rdquo;. I understand the intent, but not sure that <em>series</em> is the
right terminology here. I think I&rsquo;d prefer if measurements were simply
called series, and to get the equivalent of <code>SHOW SERIES</code> you&rsquo;d use
something like <code>SHOW SERIES TAGS</code>. (May be I&rsquo;m missing something.)</p>
<p>Under the hood the data is stored in shards, which are grouped by
shard groups, which in turn are grouped by retention policies, and
finally databases.</p>
<p>A database contains one or more retention policies. Somewhat
surprisingly a retention policy is actually a bucket. It makes sense
if you think about the problem of having to expire data points - you
can remove them all by simply dropping the entire bucket.</p>
<p>If we declare a retention policy of 1 day, then we can logically
divide the timeline into a sequence of single days from beginning of
the epoch. Any incoming data point falls into its corresponding
segment, which is a retention policy bucket. When clean up time comes
around, we can delete all days except for the most current day.</p>
<p>To better understand the following paragraphs, consider that having
multiple nodes provides the option for two things: <em>redundancy</em> and
<em>distribution</em>. Redundancy gives you the ability to lose a node
without losing any data. The number of copies of the data is
controlled by the replication factor specified as part of the
retention policy. Distribution spreads the data across nodes which
allows for concurrency: data can be written, read and processed in
parallel. For example if we become constrained by write performance,
we can solve this by simply adding more nodes. InfluxDB favors
redundancy over distribution when having to choose between the two.</p>
<p>Each retention policy bucket is further divided into shard groups, one
shard group per series. The purpose of a shard group is to balance
series data across the nodes of the cluster. If we have a cluster of 3
nodes, we want the data points to be evenly distributed across these
nodes. InfluxDB will create 3 shards, one on each of the nodes. The 3
shards comprise the shard group. This is assuming the replication
factor is 1.</p>
<p>But if the replication factor was 2, then there needs to be 2
identical copies of every shard. The shard copies must be on separate
nodes. With 3 nodes and replication factor of 2, it is impossible to
do any distribution across the nodes - the shard group will have a
size of 1, and contain 1 shard, replicated across 2 nodes. In this set
up, the third node will have no data for this particular retention
policy.</p>
<p>If we had a cluster of 5 nodes and the replication factor of 2, then
the shard group can have a size of 2, for 2 shards, replicated across
2 nodes each. Shard one replicas could live on nodes 1 and 3, while
shard two replicas on nodes 2 and 4. Now the data is distributed as
well as redundant. Note that the 5th node doesn&rsquo;t do anything. If we
up the replication factor to 3 then just like before, the cluster is
too small to have any distribution, we only have enough nodes for
redundancy.</p>
<p>As of RC15 distributed queries are not yet implemented, so you will
always get an error if you have more than one shard in a group.</p>
<p>The shards themselves are instances of <a href="https://github.com/boltdb/bolt">Bolt db</a> - a simple to use key/value store
written in Go. There is also a separate Bolt db file called meta which
stores the metadata, i.e. information about databases, retention
policies, measurements, series, etc.</p>
<p>I couldn&rsquo;t quite figure out the process for typical cluster operations
such as recovery from node failure or what happens (or should happen)
when nodes are added to existing cluster, whether there is a way to
decommission a node or re-balance the cluster similar to the Hadoop
balancer, etc. I think as of this writing this has not been fully
implemented yet, and there is no documentation, but hopefully it&rsquo;s
coming soon.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="https://grisha.org/" >
    &copy;  Gregory Trubetskoy 2026 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
