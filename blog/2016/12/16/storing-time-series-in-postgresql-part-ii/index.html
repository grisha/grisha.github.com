<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Storing Time Series in PostgreSQL (Continued) | Gregory Trubetskoy</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Edit: there is now a part iii in this series of articles.
I have previously written how
time series can be stored in PostgreSQL efficiently using arrays.
As a continuation of that article, I shall attempt to describe in detail the inner workings of an
SQL view that Tgres uses to
make an array of numbers appear as a regular table
(link to code).
In short, I will explain how incomprehensible data like this:
=&gt; select * from ts;
 rra_id | n |           dp
--------&#43;---&#43;------------------------
      1 | 0 | {64,67,70,71,72,69,67}
      1 | 1 | {65,60,58,59,62,68,70}
      1 | 2 | {71,72,77,70,71,73,75}
      1 | 3 | {79,82,90,69,75,80,81}
&hellip; can be transformed in an SQL view to appear as so:">
    <meta name="generator" content="Hugo 0.146.0">
    
    
    
      <meta name="robots" content="index, follow">
    
    <meta name="author" content="Gregory Trubetskoy">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.d05fb5f317fcf33b3a52936399bdf6f47dc776516e1692e412ec7d76f4a5faa2.css" >




    


    
      

    

    

    
      <link rel="canonical" href="https://grisha.org/blog/2016/12/16/storing-time-series-in-postgresql-part-ii/">
    

    
    
    <meta property="og:url" content="https://grisha.org/blog/2016/12/16/storing-time-series-in-postgresql-part-ii/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="Storing Time Series in PostgreSQL (Continued)">
  <meta property="og:description" content="Edit: there is now a part iii in this series of articles.
I have previously written how time series can be stored in PostgreSQL efficiently using arrays.
As a continuation of that article, I shall attempt to describe in detail the inner workings of an SQL view that Tgres uses to make an array of numbers appear as a regular table (link to code).
In short, I will explain how incomprehensible data like this:
=&gt; select * from ts; rra_id | n | dp --------&#43;---&#43;------------------------ 1 | 0 | {64,67,70,71,72,69,67} 1 | 1 | {65,60,58,59,62,68,70} 1 | 2 | {71,72,77,70,71,73,75} 1 | 3 | {79,82,90,69,75,80,81} … can be transformed in an SQL view to appear as so:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2016-12-16T19:35:00+00:00">
    <meta property="article:modified_time" content="2016-12-16T19:35:00+00:00">

  <meta itemprop="name" content="Storing Time Series in PostgreSQL (Continued)">
  <meta itemprop="description" content="Edit: there is now a part iii in this series of articles.
I have previously written how time series can be stored in PostgreSQL efficiently using arrays.
As a continuation of that article, I shall attempt to describe in detail the inner workings of an SQL view that Tgres uses to make an array of numbers appear as a regular table (link to code).
In short, I will explain how incomprehensible data like this:
=&gt; select * from ts; rra_id | n | dp --------&#43;---&#43;------------------------ 1 | 0 | {64,67,70,71,72,69,67} 1 | 1 | {65,60,58,59,62,68,70} 1 | 2 | {71,72,77,70,71,73,75} 1 | 3 | {79,82,90,69,75,80,81} … can be transformed in an SQL view to appear as so:">
  <meta itemprop="datePublished" content="2016-12-16T19:35:00+00:00">
  <meta itemprop="dateModified" content="2016-12-16T19:35:00+00:00">
  <meta itemprop="wordCount" content="1259">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Storing Time Series in PostgreSQL (Continued)">
  <meta name="twitter:description" content="Edit: there is now a part iii in this series of articles.
I have previously written how time series can be stored in PostgreSQL efficiently using arrays.
As a continuation of that article, I shall attempt to describe in detail the inner workings of an SQL view that Tgres uses to make an array of numbers appear as a regular table (link to code).
In short, I will explain how incomprehensible data like this:
=&gt; select * from ts; rra_id | n | dp --------&#43;---&#43;------------------------ 1 | 0 | {64,67,70,71,72,69,67} 1 | 1 | {65,60,58,59,62,68,70} 1 | 2 | {71,72,77,70,71,73,75} 1 | 3 | {79,82,90,69,75,80,81} … can be transformed in an SQL view to appear as so:">

      
      
    
	
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$', '$'] ],
      displayMath: [ ['$$', '$$']],
      processEscapes: true,
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  </head><body class="ma0 avenir bg-near-white production">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Gregory Trubetskoy
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/archives/" title="Archives page">
              Archives
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l mw7 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Storing Time Series in PostgreSQL (Continued)</h1>
      
      <p class="tracked"><strong>Gregory Trubetskoy</strong>
      </p>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2016-12-16T19:35:00Z">December 16, 2016</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-100-l"><p>Edit: there is now a <a href="/blog/2017/01/21/storing-time-seris-in-postgresql-optimize-for-write">part iii</a> in this series of articles.</p>
<p>I have <a href="/blog/2015/09/23/storing-time-series-in-postgresql-efficiently/">previously written</a> how
time series can be stored in PostgreSQL efficiently using <a href="https://www.postgresql.org/docs/current/static/arrays.html">arrays</a>.</p>
<p>As a continuation of that article, I shall attempt to describe in detail the inner workings of an
<a href="https://en.wikipedia.org/wiki/View_(SQL)">SQL view</a> that <a href="https://github.com/tgres/tgres">Tgres</a> uses to
make an array of numbers appear as a regular table
(<a href="https://github.com/tgres/tgres/blob/bc718e3999650b7aab934517179ea47632530d28/serde/postgres.go#L235-L242">link to code</a>).</p>
<p>In short, I will explain how incomprehensible data like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> ts;
</span></span><span style="display:flex;"><span> rra_id <span style="color:#f92672">|</span> n <span style="color:#f92672">|</span>           dp
</span></span><span style="display:flex;"><span><span style="color:#75715e">--------+---+------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">{</span><span style="color:#ae81ff">64</span>,<span style="color:#ae81ff">67</span>,<span style="color:#ae81ff">70</span>,<span style="color:#ae81ff">71</span>,<span style="color:#ae81ff">72</span>,<span style="color:#ae81ff">69</span>,<span style="color:#ae81ff">67</span><span style="color:#960050;background-color:#1e0010">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">{</span><span style="color:#ae81ff">65</span>,<span style="color:#ae81ff">60</span>,<span style="color:#ae81ff">58</span>,<span style="color:#ae81ff">59</span>,<span style="color:#ae81ff">62</span>,<span style="color:#ae81ff">68</span>,<span style="color:#ae81ff">70</span><span style="color:#960050;background-color:#1e0010">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">{</span><span style="color:#ae81ff">71</span>,<span style="color:#ae81ff">72</span>,<span style="color:#ae81ff">77</span>,<span style="color:#ae81ff">70</span>,<span style="color:#ae81ff">71</span>,<span style="color:#ae81ff">73</span>,<span style="color:#ae81ff">75</span><span style="color:#960050;background-color:#1e0010">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">{</span><span style="color:#ae81ff">79</span>,<span style="color:#ae81ff">82</span>,<span style="color:#ae81ff">90</span>,<span style="color:#ae81ff">69</span>,<span style="color:#ae81ff">75</span>,<span style="color:#ae81ff">80</span>,<span style="color:#ae81ff">81</span><span style="color:#960050;background-color:#1e0010">}</span>
</span></span></code></pre></div><p>&hellip; can be transformed in an SQL view to appear as so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> tv <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> t;
</span></span><span style="display:flex;"><span> rra_id <span style="color:#f92672">|</span>           t            <span style="color:#f92672">|</span> r
</span></span><span style="display:flex;"><span><span style="color:#75715e">--------+------------------------+----
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">2008</span><span style="color:#f92672">-</span><span style="color:#ae81ff">03</span><span style="color:#f92672">-</span><span style="color:#ae81ff">06</span> <span style="color:#ae81ff">00</span>:<span style="color:#ae81ff">00</span>:<span style="color:#ae81ff">00</span><span style="color:#f92672">+</span><span style="color:#ae81ff">00</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">2008</span><span style="color:#f92672">-</span><span style="color:#ae81ff">03</span><span style="color:#f92672">-</span><span style="color:#ae81ff">07</span> <span style="color:#ae81ff">00</span>:<span style="color:#ae81ff">00</span>:<span style="color:#ae81ff">00</span><span style="color:#f92672">+</span><span style="color:#ae81ff">00</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">67</span>
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">2008</span><span style="color:#f92672">-</span><span style="color:#ae81ff">03</span><span style="color:#f92672">-</span><span style="color:#ae81ff">08</span> <span style="color:#ae81ff">00</span>:<span style="color:#ae81ff">00</span>:<span style="color:#ae81ff">00</span><span style="color:#f92672">+</span><span style="color:#ae81ff">00</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">70</span>
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">2008</span><span style="color:#f92672">-</span><span style="color:#ae81ff">03</span><span style="color:#f92672">-</span><span style="color:#ae81ff">09</span> <span style="color:#ae81ff">00</span>:<span style="color:#ae81ff">00</span>:<span style="color:#ae81ff">00</span><span style="color:#f92672">+</span><span style="color:#ae81ff">00</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">71</span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>This write up will make a lot more sense if you read the
<a href="/blog/2015/09/23/storing-time-series-in-postgresql-efficiently/">previous post</a> first.
To recap, Tgres stores series in an array broken up over multiple
table rows each containing an array representing a segment of the
series. The series array is a round-robin structure, which means
that it occupies a fixed amount of space and we do not need to worry
about expiring data points: the round-robin nature of the array
takes care of it by overwriting old data with new on assignment.</p>
<p>An additional benefit of such a fixed interval round-robin structure
is that we do not need to store timestamps for every data point. If we
know the timestamp of the latest entry along with the series step and size,
we can extrapolate the timestamp of any point in the series.</p>
<p>Tgres creates an SQL view which takes care of this extrapolation and
makes this data easy to query. Tgres actually uses this view as its
only source of time series information when reading from the database
thus delegating all the processing to the database server, where it is
close to the data and most efficient.</p>
<p>If you would like to follow along on the Postgres command line, feel
free to create and populate the tables with the following SQL, which
is nearly identical to the schema used by Tgres:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> rra (
</span></span><span style="display:flex;"><span>  id SERIAL <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>  step_s INT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  steps_per_row INT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">size</span> INT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  width INT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  latest TIMESTAMPTZ <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> ts (
</span></span><span style="display:flex;"><span>  rra_id INT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  n INT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  dp DOUBLE <span style="color:#66d9ef">PRECISION</span>[] <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#e6db74">&#39;{}&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> rra <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">60</span>, <span style="color:#ae81ff">1440</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">7</span>, <span style="color:#e6db74">&#39;2008-04-02 00:00:00-00&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> ts <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#39;{64,67,70,71,72,69,67}&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> ts <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;{65,60,58,59,62,68,70}&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> ts <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;{71,72,77,70,71,73,75}&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> ts <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;{79,82,90,69,75,80,81}&#39;</span>);
</span></span></code></pre></div><p>And finally create the view:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">VIEW</span> tv <span style="color:#66d9ef">AS</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">SELECT</span> rra.id rra_id,
</span></span><span style="display:flex;"><span>         latest <span style="color:#f92672">-</span> INTERVAL <span style="color:#e6db74">&#39;1 SECOND&#39;</span> <span style="color:#f92672">*</span> rra.step_s <span style="color:#f92672">*</span> rra.steps_per_row <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">MOD</span>(rra.<span style="color:#66d9ef">size</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">MOD</span>(<span style="color:#66d9ef">EXTRACT</span>(EPOCH <span style="color:#66d9ef">FROM</span> rra.latest)::BIGINT<span style="color:#f92672">/</span>(rra.step_s <span style="color:#f92672">*</span> rra.steps_per_row), <span style="color:#66d9ef">size</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>           <span style="color:#f92672">-</span> (generate_subscripts(dp,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> n <span style="color:#f92672">*</span> width), rra.<span style="color:#66d9ef">size</span>) <span style="color:#66d9ef">AS</span> t,
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">UNNEST</span>(dp) <span style="color:#66d9ef">AS</span> r
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">FROM</span> rra
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> ts ts <span style="color:#66d9ef">ON</span> ts.rra_id <span style="color:#f92672">=</span> rra.id;
</span></span></code></pre></div><p>Now give it a whirl with a <code>SELECT * FROM tv ORDER BY t</code>. Impressive? So how does it work?</p>
<p>First let&rsquo;s go over the columns of the rra table.</p>
<ul>
<li><code>step_s</code>: the minimal unit of time expressed in seconds (60 or 1 minute in the above data).</li>
<li><code>steps_per_row</code>: the number of the <code>step_s</code> intervals in one slot of our time series.
In our example it is 1440, which is the number of minutes in a day, thus making our time series
resolution <em>one day</em>.</li>
<li><code>size</code>: number of slots in the series. Ours is 28, i.e. four weeks.</li>
<li><code>width</code>: size of a segment which will be stored in a single row, which in our case
is 7 (one week).</li>
<li><code>latest</code>: the timestamp of the last data point in the series.</li>
</ul>
<p>Next, let&rsquo;s look at the <code>UNNEST</code> keyword in the SQL of the view. <code>UNNEST</code> takes an array and turns it into row, e.g.:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">UNNEST</span>(dp) <span style="color:#66d9ef">AS</span> r <span style="color:#66d9ef">FROM</span> ts;
</span></span><span style="display:flex;"><span> r
</span></span><span style="display:flex;"><span><span style="color:#75715e">----
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">67</span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p><code>UNNEST</code> works in conjunction with the <code>generate_subscripts</code>
PostgreSQL function which generates index values:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">SELECT</span> generate_subscripts(dp,<span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">AS</span> i, <span style="color:#66d9ef">UNNEST</span>(dp) <span style="color:#66d9ef">AS</span> r <span style="color:#66d9ef">FROM</span> ts;
</span></span><span style="display:flex;"><span> i <span style="color:#f92672">|</span> r
</span></span><span style="display:flex;"><span><span style="color:#75715e">---+----
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">67</span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>Let us now zoom in on the very long expression in the view, here it is again:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>latest <span style="color:#f92672">-</span> INTERVAL <span style="color:#e6db74">&#39;1 SECOND&#39;</span> <span style="color:#f92672">*</span> rra.step_s <span style="color:#f92672">*</span> rra.steps_per_row <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">MOD</span>(rra.<span style="color:#66d9ef">size</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">MOD</span>(<span style="color:#66d9ef">EXTRACT</span>(EPOCH <span style="color:#66d9ef">FROM</span> rra.latest)::BIGINT<span style="color:#f92672">/</span>(rra.step_s <span style="color:#f92672">*</span> rra.steps_per_row), <span style="color:#66d9ef">size</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">-</span> (generate_subscripts(dp,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> n <span style="color:#f92672">*</span> width), rra.<span style="color:#66d9ef">size</span>) <span style="color:#66d9ef">AS</span> t
</span></span></code></pre></div><p>A perhaps not immediately apparent trick to how all this works is that all
our series are aligned
on the <a href="https://en.wikipedia.org/wiki/Unix_time">beginning of the epoch</a>.
This means that at UNIX time 0, any series&rsquo; slot index is 0. From then on it
increments sequentially until the series size is reached, at which point
it wraps-around to 0 (thus &ldquo;round-robin&rdquo;). Armed with this information we
can calculate the index for any point in time.</p>
<p>The formula for calculating the index <code>i</code> for a given time <code>t</code> is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>i <span style="color:#f92672">=</span> t<span style="color:#f92672">/</span>step <span style="color:#f92672">%</span> size<span style="color:#f92672">.</span>
</span></span></code></pre></div><p>We need time to be expressed as a UNIX time which is done
with <code>EXTRACT(EPOCH FROM rra.latest)::BIGINT</code>. Now you should recognize
the above formula in the more verbose expression</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">MOD</span>(<span style="color:#66d9ef">EXTRACT</span>(EPOCH <span style="color:#66d9ef">FROM</span> rra.latest)::BIGINT<span style="color:#f92672">/</span>(rra.step_s <span style="color:#f92672">*</span> rra.steps_per_row), <span style="color:#66d9ef">size</span>)
</span></span></code></pre></div><p>where <code>rra.step_s * rra.steps_per_row</code> is the size of our series in seconds.</p>
<p>Next, we need to compute the <em>distance</em> between the current slot and the
last slot (for which we know the timestamp). I.e. if the last slot is <code>i</code> and the slot we need the
timestamp for is <code>j</code>, the distance between them is <code>i-j</code>, but with a
caveat: it is possible for <code>j</code> to be greater than <code>i</code> if the series
wraps around, in which case the distance is the sum of the distance from
<code>j</code> to the end of the series and the distance from the beginning to
<code>i</code>. If you ponder over it with a pencil and paper long enough, you
will arrive at the following formula for distance between two slots
<code>i</code> and <code>j</code> in a wrap-around array:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>distance <span style="color:#f92672">=</span> (size <span style="color:#f92672">+</span> i <span style="color:#f92672">-</span> j) <span style="color:#f92672">%</span> size
</span></span></code></pre></div><p>Another thing to consider is that we&rsquo;re splitting our series across
multiple rows, thus the actual index of any point is the subscript
into the current segment plus the index of the segment itself (the <code>n</code>
column) multiplied by the <code>wdith</code> of the segment: <code>generate_subscripts(dp,1) + n * width</code>.</p>
<p>Which pieced together in SQL now looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">MOD</span>(rra.<span style="color:#66d9ef">size</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">MOD</span>(<span style="color:#66d9ef">EXTRACT</span>(EPOCH <span style="color:#66d9ef">FROM</span> rra.latest)::BIGINT<span style="color:#f92672">/</span>(rra.step_s <span style="color:#f92672">*</span> rra.steps_per_row), <span style="color:#66d9ef">size</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">-</span> (generate_subscripts(dp,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> n <span style="color:#f92672">*</span> width), rra.<span style="color:#66d9ef">size</span>)
</span></span></code></pre></div><p>Astute readers should notice an unexplained <code>+ 1</code>. This is because
PostgreSQL arrays are 1-based.</p>
<p>Now we need to convert the distance expressed in array slots into
a time interval, which we do by multiplying it by
<code>INTERVAL '1 SECOND' * rra.step_s * rra.steps_per_row</code>.</p>
<p>And finally, we need to subtract the above time interval from the
latest stamp which yields (ta-da!) the timestamp of the current slot:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>latest <span style="color:#f92672">-</span> INTERVAL <span style="color:#e6db74">&#39;1 SECOND&#39;</span> <span style="color:#f92672">*</span> rra.step_s <span style="color:#f92672">*</span> rra.steps_per_row <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">MOD</span>(rra.<span style="color:#66d9ef">size</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">MOD</span>(<span style="color:#66d9ef">EXTRACT</span>(EPOCH <span style="color:#66d9ef">FROM</span> rra.latest)::BIGINT<span style="color:#f92672">/</span>(rra.step_s <span style="color:#f92672">*</span> rra.steps_per_row), <span style="color:#66d9ef">size</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">-</span> (generate_subscripts(dp,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> n <span style="color:#f92672">*</span> width), rra.<span style="color:#66d9ef">size</span>) <span style="color:#66d9ef">AS</span> t
</span></span></code></pre></div><p>That&rsquo;s it! And even though this may look complicated, from the
computational view point it is very efficient, and PostgreSQL can
handle it easily.</p>
<p>As an exercise, try setting <code>latest</code> to various timestamps and observe
how it affects the output of the view and see if you can explain how
and why it happens.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="https://grisha.org/" >
    &copy;  Gregory Trubetskoy 2026 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
