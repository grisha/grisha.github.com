<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Simple Tgres Part II - A High Rate Counter - Gregory Trubetskoy</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="Continuing on the the previous post on simple use of Tgres components, let&rsquo;s try to count something that goes by really fast.
This time let&rsquo;s start out with creating a memory-based SerDe. This means that all our data is in memory and there is no database backing our series.
package main import ( &#34;fmt&#34; &#34;net/http&#34; &#34;time&#34; &#34;github.com/tgres/tgres/dsl&#34; h &#34;github.com/tgres/tgres/http&#34; &#34;github.com/tgres/tgres/receiver&#34; &#34;github.com/tgres/tgres/rrd&#34; &#34;github.com/tgres/tgres/serde&#34; ) func main() { step := 1 * time.Second // 1 second resolution span := 600 * step // spanning 10 minutes // In-memory SerDe ms := serde.NewMemSerDe() // Create a receiver of our data points backed by the above // memory SerDe rcvr := receiver.New(ms, &amp;receiver.SimpleDSFinder{&amp;rrd.DSSpec{ Step: step, RRAs: []rrd.RRASpec{ rrd.RRASpec{Function: rrd.WMEAN, Step: step, Span: span, }, }}}) rcvr.Start() Now let&rsquo;s create a goroutine which creates data points as fast as it can, the difference from the previous blog post is that we are using QueueGauge(), which is a paced metric, meaning that it flushes to the time series only periodically (once per second by default) so as to not overwhelm the I/O and or network (even though in this case it doesn&rsquo;t really matter since we&rsquo;re using a memory-based SerDe anyway).
" />






<meta name="generator" content="Hugo 0.146.0 with theme even" />


<link rel="canonical" href="https://grisha.org/blog/2016/12/28/simple-tgres-part-ii-a-high-rate-counter/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">

<link rel="stylesheet" href="/css/custom.css">


<meta property="og:url" content="https://grisha.org/blog/2016/12/28/simple-tgres-part-ii-a-high-rate-counter/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="Simple Tgres Part II - A High Rate Counter">
  <meta property="og:description" content="Continuing on the the previous post on simple use of Tgres components, let’s try to count something that goes by really fast.
This time let’s start out with creating a memory-based SerDe. This means that all our data is in memory and there is no database backing our series.
package main import ( &#34;fmt&#34; &#34;net/http&#34; &#34;time&#34; &#34;github.com/tgres/tgres/dsl&#34; h &#34;github.com/tgres/tgres/http&#34; &#34;github.com/tgres/tgres/receiver&#34; &#34;github.com/tgres/tgres/rrd&#34; &#34;github.com/tgres/tgres/serde&#34; ) func main() { step := 1 * time.Second // 1 second resolution span := 600 * step // spanning 10 minutes // In-memory SerDe ms := serde.NewMemSerDe() // Create a receiver of our data points backed by the above // memory SerDe rcvr := receiver.New(ms, &amp;receiver.SimpleDSFinder{&amp;rrd.DSSpec{ Step: step, RRAs: []rrd.RRASpec{ rrd.RRASpec{Function: rrd.WMEAN, Step: step, Span: span, }, }}}) rcvr.Start() Now let’s create a goroutine which creates data points as fast as it can, the difference from the previous blog post is that we are using QueueGauge(), which is a paced metric, meaning that it flushes to the time series only periodically (once per second by default) so as to not overwhelm the I/O and or network (even though in this case it doesn’t really matter since we’re using a memory-based SerDe anyway).">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2016-12-28T17:06:00+00:00">
    <meta property="article:modified_time" content="2016-12-28T17:06:00+00:00">

  <meta itemprop="name" content="Simple Tgres Part II - A High Rate Counter">
  <meta itemprop="description" content="Continuing on the the previous post on simple use of Tgres components, let’s try to count something that goes by really fast.
This time let’s start out with creating a memory-based SerDe. This means that all our data is in memory and there is no database backing our series.
package main import ( &#34;fmt&#34; &#34;net/http&#34; &#34;time&#34; &#34;github.com/tgres/tgres/dsl&#34; h &#34;github.com/tgres/tgres/http&#34; &#34;github.com/tgres/tgres/receiver&#34; &#34;github.com/tgres/tgres/rrd&#34; &#34;github.com/tgres/tgres/serde&#34; ) func main() { step := 1 * time.Second // 1 second resolution span := 600 * step // spanning 10 minutes // In-memory SerDe ms := serde.NewMemSerDe() // Create a receiver of our data points backed by the above // memory SerDe rcvr := receiver.New(ms, &amp;receiver.SimpleDSFinder{&amp;rrd.DSSpec{ Step: step, RRAs: []rrd.RRASpec{ rrd.RRASpec{Function: rrd.WMEAN, Step: step, Span: span, }, }}}) rcvr.Start() Now let’s create a goroutine which creates data points as fast as it can, the difference from the previous blog post is that we are using QueueGauge(), which is a paced metric, meaning that it flushes to the time series only periodically (once per second by default) so as to not overwhelm the I/O and or network (even though in this case it doesn’t really matter since we’re using a memory-based SerDe anyway).">
  <meta itemprop="datePublished" content="2016-12-28T17:06:00+00:00">
  <meta itemprop="dateModified" content="2016-12-28T17:06:00+00:00">
  <meta itemprop="wordCount" content="378">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Simple Tgres Part II - A High Rate Counter">
  <meta name="twitter:description" content="Continuing on the the previous post on simple use of Tgres components, let’s try to count something that goes by really fast.
This time let’s start out with creating a memory-based SerDe. This means that all our data is in memory and there is no database backing our series.
package main import ( &#34;fmt&#34; &#34;net/http&#34; &#34;time&#34; &#34;github.com/tgres/tgres/dsl&#34; h &#34;github.com/tgres/tgres/http&#34; &#34;github.com/tgres/tgres/receiver&#34; &#34;github.com/tgres/tgres/rrd&#34; &#34;github.com/tgres/tgres/serde&#34; ) func main() { step := 1 * time.Second // 1 second resolution span := 600 * step // spanning 10 minutes // In-memory SerDe ms := serde.NewMemSerDe() // Create a receiver of our data points backed by the above // memory SerDe rcvr := receiver.New(ms, &amp;receiver.SimpleDSFinder{&amp;rrd.DSSpec{ Step: step, RRAs: []rrd.RRASpec{ rrd.RRASpec{Function: rrd.WMEAN, Step: step, Span: span, }, }}}) rcvr.Start() Now let’s create a goroutine which creates data points as fast as it can, the difference from the previous blog post is that we are using QueueGauge(), which is a paced metric, meaning that it flushes to the time series only periodically (once per second by default) so as to not overwhelm the I/O and or network (even though in this case it doesn’t really matter since we’re using a memory-based SerDe anyway).">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Gregory Trubetskoy</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/posts/">
        <li class="mobile-menu-item">Archives</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Gregory Trubetskoy</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/posts/">Archives</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Simple Tgres Part II - A High Rate Counter</h1>

      <div class="post-meta">
        <span class="post-time"> 2016-12-28 </span>
        
        
      </div>
    </header>

    
    <div class="post-content">
      <p>Continuing on the <a href="/blog/2016/12/21/simple-time-series-app-with-tgres/">the previous</a>
post on simple use of <a href="https://github.com/tgres/tgres">Tgres</a> components, let&rsquo;s
try to count something that goes by really fast.</p>
<p>This time let&rsquo;s start out with creating a memory-based SerDe. This
means that all our data is in memory and there is no database backing
our series.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;net/http&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/tgres/tgres/dsl&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">h</span> <span style="color:#e6db74">&#34;github.com/tgres/tgres/http&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/tgres/tgres/receiver&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/tgres/tgres/rrd&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/tgres/tgres/serde&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">step</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span> <span style="color:#75715e">// 1 second resolution</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">span</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">600</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">step</span>      <span style="color:#75715e">// spanning 10 minutes</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// In-memory SerDe</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ms</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">serde</span>.<span style="color:#a6e22e">NewMemSerDe</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create a receiver of our data points backed by the above</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// memory SerDe</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rcvr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">receiver</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">ms</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">receiver</span>.<span style="color:#a6e22e">SimpleDSFinder</span>{<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">rrd</span>.<span style="color:#a6e22e">DSSpec</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Step</span>: <span style="color:#a6e22e">step</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">RRAs</span>: []<span style="color:#a6e22e">rrd</span>.<span style="color:#a6e22e">RRASpec</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">rrd</span>.<span style="color:#a6e22e">RRASpec</span>{<span style="color:#a6e22e">Function</span>: <span style="color:#a6e22e">rrd</span>.<span style="color:#a6e22e">WMEAN</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Step</span>: <span style="color:#a6e22e">step</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Span</span>: <span style="color:#a6e22e">span</span>,
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>        }}})
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rcvr</span>.<span style="color:#a6e22e">Start</span>()
</span></span></code></pre></div><p>Now let&rsquo;s create a goroutine which creates data points as fast as it
can, the difference from the previous blog post is that we are using
QueueGauge(), which is a <em>paced metric</em>, meaning that it flushes to the
time series only periodically (once per second by default) so as to
not overwhelm the I/O and or network (even though in this case it doesn&rsquo;t
really matter since we&rsquo;re using a memory-based SerDe anyway).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>    <span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">start</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">span</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(); <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Before</span>(<span style="color:#a6e22e">end</span>); <span style="color:#a6e22e">t</span> = <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">rcvr</span>.<span style="color:#a6e22e">QueueGauge</span>(<span style="color:#a6e22e">serde</span>.<span style="color:#a6e22e">Ident</span>{<span style="color:#e6db74">&#34;name&#34;</span>:<span style="color:#e6db74">&#34;foo.bar&#34;</span>}, float64(<span style="color:#a6e22e">n</span>)<span style="color:#f92672">/</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Sub</span>(<span style="color:#a6e22e">start</span>)).<span style="color:#a6e22e">Seconds</span>())
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }()
</span></span></code></pre></div><p>And finally, as before, we need to hook up a couple of http handlers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>    <span style="color:#a6e22e">db</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dsl</span>.<span style="color:#a6e22e">NewNamedDSFetcher</span>(<span style="color:#a6e22e">ms</span>.<span style="color:#a6e22e">Fetcher</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/metrics/find&#34;</span>, <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">GraphiteMetricsFindHandler</span>(<span style="color:#a6e22e">db</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/render&#34;</span>, <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">GraphiteRenderHandler</span>(<span style="color:#a6e22e">db</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">listenSpec</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;:8088&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Waiting for requests on %s\n&#34;</span>, <span style="color:#a6e22e">listenSpec</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ListenAndServe</span>(<span style="color:#a6e22e">listenSpec</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// end of main()</span>
</span></span></code></pre></div><p>Now if we run the above code with something like
<code>go run simpletgres.go</code>, we&rsquo;ll notice that unlike with the previous
example, the web server starts right away, and the data points are
being written while the server is running. If we aim Grafana at it,
we should be able to see the chart update in real time.</p>
<p>After a couple of minutes, mine looks like this:</p>
<p><img src="/images/simple-tgres01.png" alt=""></p>
<p>So my macbook can crank these out at about 2.5 million per second.</p>
<p>In my experience instrumenting my apps with simple counters like this
and having them available directly from the app without having to send
them to a separate statsd server somewhere has been extremely useful in
helping understand performance and other issues.</p>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/blog/2017/01/21/storing-time-seris-in-postgresql-optimize-for-write/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Storing Time Series in PostgreSQL - Optimize for Write</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/blog/2016/12/23/time-series-what-is-it/">
            <span class="next-text nav-default">Why is there no Formal Definition of Time Series?</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'grisha';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2013 - 
    2026<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
