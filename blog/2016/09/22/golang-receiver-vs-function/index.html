<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Golang receiver vs function argument - Gregory Trubetskoy</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="What is the difference between a Go receiver (as in &ldquo;method receiver&rdquo;) and a function argument? Consider these two bits of code:
func (d *duck) quack() { // receiver // do something } versus
func quack(d *duck) { // funciton argument // do something } The &ldquo;do something&rdquo; part above would work exactly the same regardless of how you declare the function. Which begs the question, which should you use?
In the object-oriented world we were used to objects doing things, and in that context d.quack() may seem more intuitive or familiar than quack(d) because it &ldquo;reads better&rdquo;. After all, one could argue that the former is a duck quacking, but the latter reads like you&rsquo;re quacking a duck, and what does that even mean? I have learned that you should not think this way in the Go universe, and here is why.
" />






<meta name="generator" content="Hugo 0.146.0 with theme even" />


<link rel="canonical" href="https://grisha.org/blog/2016/09/22/golang-receiver-vs-function/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">

<link rel="stylesheet" href="/css/custom.css">


<meta property="og:url" content="https://grisha.org/blog/2016/09/22/golang-receiver-vs-function/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="Golang receiver vs function argument">
  <meta property="og:description" content="What is the difference between a Go receiver (as in “method receiver”) and a function argument? Consider these two bits of code:
func (d *duck) quack() { // receiver // do something } versus
func quack(d *duck) { // funciton argument // do something } The “do something” part above would work exactly the same regardless of how you declare the function. Which begs the question, which should you use?
In the object-oriented world we were used to objects doing things, and in that context d.quack() may seem more intuitive or familiar than quack(d) because it “reads better”. After all, one could argue that the former is a duck quacking, but the latter reads like you’re quacking a duck, and what does that even mean? I have learned that you should not think this way in the Go universe, and here is why.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2016-09-22T08:15:00+00:00">
    <meta property="article:modified_time" content="2016-09-22T08:15:00+00:00">

  <meta itemprop="name" content="Golang receiver vs function argument">
  <meta itemprop="description" content="What is the difference between a Go receiver (as in “method receiver”) and a function argument? Consider these two bits of code:
func (d *duck) quack() { // receiver // do something } versus
func quack(d *duck) { // funciton argument // do something } The “do something” part above would work exactly the same regardless of how you declare the function. Which begs the question, which should you use?
In the object-oriented world we were used to objects doing things, and in that context d.quack() may seem more intuitive or familiar than quack(d) because it “reads better”. After all, one could argue that the former is a duck quacking, but the latter reads like you’re quacking a duck, and what does that even mean? I have learned that you should not think this way in the Go universe, and here is why.">
  <meta itemprop="datePublished" content="2016-09-22T08:15:00+00:00">
  <meta itemprop="dateModified" content="2016-09-22T08:15:00+00:00">
  <meta itemprop="wordCount" content="455">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Golang receiver vs function argument">
  <meta name="twitter:description" content="What is the difference between a Go receiver (as in “method receiver”) and a function argument? Consider these two bits of code:
func (d *duck) quack() { // receiver // do something } versus
func quack(d *duck) { // funciton argument // do something } The “do something” part above would work exactly the same regardless of how you declare the function. Which begs the question, which should you use?
In the object-oriented world we were used to objects doing things, and in that context d.quack() may seem more intuitive or familiar than quack(d) because it “reads better”. After all, one could argue that the former is a duck quacking, but the latter reads like you’re quacking a duck, and what does that even mean? I have learned that you should not think this way in the Go universe, and here is why.">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Gregory Trubetskoy</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/posts/">
        <li class="mobile-menu-item">Archives</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Gregory Trubetskoy</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/posts/">Archives</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Golang receiver vs function argument</h1>

      <div class="post-meta">
        <span class="post-time"> 2016-09-22 </span>
        
        
      </div>
    </header>

    
    <div class="post-content">
      <p>What is the difference between a Go <em>receiver</em> (as in &ldquo;method receiver&rdquo;)
and a function <em>argument</em>? Consider these two bits of code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) <span style="color:#a6e22e">quack</span>() { <span style="color:#75715e">// receiver</span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>versus</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">quack</span>(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) { <span style="color:#75715e">// funciton argument</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The &ldquo;do something&rdquo; part above would work exactly the same regardless of
how you declare the function. Which begs the question, which should
you use?</p>
<p>In the object-oriented world we were used to objects doing things, and
in that context <code>d.quack()</code> may seem more intuitive or familiar than
<code>quack(d)</code> because it &ldquo;reads better&rdquo;. After all, one could argue that
the former is a duck quacking, but the latter reads like you&rsquo;re
quacking a duck, and what does that even mean? I have learned that you
should not think this way in the Go universe, and here is why.</p>
<p>First, what is the essential difference? It is that at the time of the
call, the receiver is an <em>interface</em> and the function to be called is
determined <em>dynamically</em>. If you are not using interfaces, then this
doesn&rsquo;t matter whatsoever and the only benefit you are getting from
using a method is syntactic sweetness.</p>
<p>But what if you need to write a test where you want to stub out
<code>quack()</code>. If your code looks like this, then it is not possible,
because methods are attached to their types inflexibly, you cannot
change them, and there is no such thing as a &ldquo;method variable&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">duck</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) <span style="color:#a6e22e">quack</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the function we are testing:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testme</span>(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">quack</span>() <span style="color:#75715e">// cannot be stubbed</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, if you used a function argument, it would be easy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">duck</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">quack</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) {
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the function we are testing:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quack</span>(<span style="color:#a6e22e">d</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now you can assign another function to quack at test time, e.g. <code>quack = func(d *duck) { // do something else }</code>  and all is
well.</p>
<p>Alternatively, you can use an interface:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">quacker</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quack</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">duck</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) <span style="color:#a6e22e">quack</span>() { <span style="color:#75715e">// satisfies quacker</span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the function we are testing:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">quacker</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">quack</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, if we need to test <code>foo()</code> we can provide a different
<code>quacker</code>.</p>
<p>Bottom line is that it only makes sense to use a receiver if this
function is part of an interface implementation, OR if you never ever
need to augment (stub) that function for testing or some other
reason. As a practical matter, it seems like (contrary to how it&rsquo;s
done in the OO world) it is better to always start out with <code>quack(d)</code>
rather than <code>d.quack()</code>.</p>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/blog/2016/11/08/load-testing-tgres/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Load testing Tgres</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/blog/2016/08/04/data-points/">
            <span class="next-text nav-default">How Data Points Build Up</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'grisha';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2013 - 
    2026<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
