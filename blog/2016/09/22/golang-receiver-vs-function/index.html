<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Golang receiver vs function argument | Gregory Trubetskoy</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="What is the difference between a Go receiver (as in &ldquo;method receiver&rdquo;)
and a function argument? Consider these two bits of code:
func (d *duck) quack() { // receiver
     // do something
}
versus
func quack(d *duck) { // funciton argument
    // do something
}
The &ldquo;do something&rdquo; part above would work exactly the same regardless of
how you declare the function. Which begs the question, which should
you use?
In the object-oriented world we were used to objects doing things, and
in that context d.quack() may seem more intuitive or familiar than
quack(d) because it &ldquo;reads better&rdquo;. After all, one could argue that
the former is a duck quacking, but the latter reads like you&rsquo;re
quacking a duck, and what does that even mean? I have learned that you
should not think this way in the Go universe, and here is why.">
    <meta name="generator" content="Hugo 0.146.0">
    
    
    
      <meta name="robots" content="index, follow">
    
    <meta name="author" content="Gregory Trubetskoy">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.d05fb5f317fcf33b3a52936399bdf6f47dc776516e1692e412ec7d76f4a5faa2.css" >




    


    
      

    

    

    
      <link rel="canonical" href="https://grisha.org/blog/2016/09/22/golang-receiver-vs-function/">
    

    
    
    <meta property="og:url" content="https://grisha.org/blog/2016/09/22/golang-receiver-vs-function/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="Golang receiver vs function argument">
  <meta property="og:description" content="What is the difference between a Go receiver (as in “method receiver”) and a function argument? Consider these two bits of code:
func (d *duck) quack() { // receiver // do something } versus
func quack(d *duck) { // funciton argument // do something } The “do something” part above would work exactly the same regardless of how you declare the function. Which begs the question, which should you use?
In the object-oriented world we were used to objects doing things, and in that context d.quack() may seem more intuitive or familiar than quack(d) because it “reads better”. After all, one could argue that the former is a duck quacking, but the latter reads like you’re quacking a duck, and what does that even mean? I have learned that you should not think this way in the Go universe, and here is why.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2016-09-22T08:15:00+00:00">
    <meta property="article:modified_time" content="2016-09-22T08:15:00+00:00">

  <meta itemprop="name" content="Golang receiver vs function argument">
  <meta itemprop="description" content="What is the difference between a Go receiver (as in “method receiver”) and a function argument? Consider these two bits of code:
func (d *duck) quack() { // receiver // do something } versus
func quack(d *duck) { // funciton argument // do something } The “do something” part above would work exactly the same regardless of how you declare the function. Which begs the question, which should you use?
In the object-oriented world we were used to objects doing things, and in that context d.quack() may seem more intuitive or familiar than quack(d) because it “reads better”. After all, one could argue that the former is a duck quacking, but the latter reads like you’re quacking a duck, and what does that even mean? I have learned that you should not think this way in the Go universe, and here is why.">
  <meta itemprop="datePublished" content="2016-09-22T08:15:00+00:00">
  <meta itemprop="dateModified" content="2016-09-22T08:15:00+00:00">
  <meta itemprop="wordCount" content="455">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Golang receiver vs function argument">
  <meta name="twitter:description" content="What is the difference between a Go receiver (as in “method receiver”) and a function argument? Consider these two bits of code:
func (d *duck) quack() { // receiver // do something } versus
func quack(d *duck) { // funciton argument // do something } The “do something” part above would work exactly the same regardless of how you declare the function. Which begs the question, which should you use?
In the object-oriented world we were used to objects doing things, and in that context d.quack() may seem more intuitive or familiar than quack(d) because it “reads better”. After all, one could argue that the former is a duck quacking, but the latter reads like you’re quacking a duck, and what does that even mean? I have learned that you should not think this way in the Go universe, and here is why.">

      
      
    
	
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$', '$'] ],
      displayMath: [ ['$$', '$$']],
      processEscapes: true,
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  </head><body class="ma0 avenir bg-near-white production">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Gregory Trubetskoy
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/archives/" title="Archives page">
              Archives
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l mw7 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Golang receiver vs function argument</h1>
      
      <p class="tracked"><strong>Gregory Trubetskoy</strong>
      </p>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2016-09-22T08:15:00Z">September 22, 2016</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-100-l"><p>What is the difference between a Go <em>receiver</em> (as in &ldquo;method receiver&rdquo;)
and a function <em>argument</em>? Consider these two bits of code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) <span style="color:#a6e22e">quack</span>() { <span style="color:#75715e">// receiver</span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>versus</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">quack</span>(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) { <span style="color:#75715e">// funciton argument</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The &ldquo;do something&rdquo; part above would work exactly the same regardless of
how you declare the function. Which begs the question, which should
you use?</p>
<p>In the object-oriented world we were used to objects doing things, and
in that context <code>d.quack()</code> may seem more intuitive or familiar than
<code>quack(d)</code> because it &ldquo;reads better&rdquo;. After all, one could argue that
the former is a duck quacking, but the latter reads like you&rsquo;re
quacking a duck, and what does that even mean? I have learned that you
should not think this way in the Go universe, and here is why.</p>
<p>First, what is the essential difference? It is that at the time of the
call, the receiver is an <em>interface</em> and the function to be called is
determined <em>dynamically</em>. If you are not using interfaces, then this
doesn&rsquo;t matter whatsoever and the only benefit you are getting from
using a method is syntactic sweetness.</p>
<p>But what if you need to write a test where you want to stub out
<code>quack()</code>. If your code looks like this, then it is not possible,
because methods are attached to their types inflexibly, you cannot
change them, and there is no such thing as a &ldquo;method variable&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">duck</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) <span style="color:#a6e22e">quack</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the function we are testing:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">testme</span>(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">quack</span>() <span style="color:#75715e">// cannot be stubbed</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, if you used a function argument, it would be easy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">duck</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">quack</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) {
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the function we are testing:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quack</span>(<span style="color:#a6e22e">d</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now you can assign another function to quack at test time, e.g. <code>quack = func(d *duck) { // do something else }</code>  and all is
well.</p>
<p>Alternatively, you can use an interface:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">quacker</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">quack</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">duck</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">duck</span>) <span style="color:#a6e22e">quack</span>() { <span style="color:#75715e">// satisfies quacker</span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the function we are testing:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">quacker</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">quack</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, if we need to test <code>foo()</code> we can provide a different
<code>quacker</code>.</p>
<p>Bottom line is that it only makes sense to use a receiver if this
function is part of an interface implementation, OR if you never ever
need to augment (stub) that function for testing or some other
reason. As a practical matter, it seems like (contrary to how it&rsquo;s
done in the OO world) it is better to always start out with <code>quack(d)</code>
rather than <code>d.quack()</code>.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="https://grisha.org/" >
    &copy;  Gregory Trubetskoy 2026 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
