<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>On keeping lots of integers in memory | Gregory Trubetskoy</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="ar ago) I found myself needing to store large numbers of
integers in memory. The goal was to store a graph of all our
purchasers and items purchased, so that we could quickly identify
like-minded purchasers based on common purchases and make real-time
recommendations of the form &ldquo;people like you also bought&rdquo;. This
approach is commonly known as collaborative filtering,
and exactly how we did it would be a subject of some future post
(perhaps).">
    <meta name="generator" content="Hugo 0.146.0">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    <meta name="author" content="Gregory Trubetskoy">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/blog/1/01/01/on-keeping-lots-of-integers-in-memory/">
    

    
    
    <meta property="og:url" content="http://localhost:1313/blog/1/01/01/on-keeping-lots-of-integers-in-memory/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="On keeping lots of integers in memory">
  <meta property="og:description" content="ar ago) I found myself needing to store large numbers of integers in memory. The goal was to store a graph of all our purchasers and items purchased, so that we could quickly identify like-minded purchasers based on common purchases and make real-time recommendations of the form “people like you also bought”. This approach is commonly known as collaborative filtering, and exactly how we did it would be a subject of some future post (perhaps).">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">

  <meta itemprop="name" content="On keeping lots of integers in memory">
  <meta itemprop="description" content="ar ago) I found myself needing to store large numbers of integers in memory. The goal was to store a graph of all our purchasers and items purchased, so that we could quickly identify like-minded purchasers based on common purchases and make real-time recommendations of the form “people like you also bought”. This approach is commonly known as collaborative filtering, and exactly how we did it would be a subject of some future post (perhaps).">
  <meta itemprop="wordCount" content="1639">
  <meta itemprop="keywords" content="Redis,Big Memory,Recommendations">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="On keeping lots of integers in memory">
  <meta name="twitter:description" content="ar ago) I found myself needing to store large numbers of integers in memory. The goal was to store a graph of all our purchasers and items purchased, so that we could quickly identify like-minded purchasers based on common purchases and make real-time recommendations of the form “people like you also bought”. This approach is commonly known as collaborative filtering, and exactly how we did it would be a subject of some future post (perhaps).">

	
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$', '$'] ],
      displayMath: [ ['$$', '$$']],
      processEscapes: true,
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Gregory Trubetskoy
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/archives/" title="Archives page">
              Archives
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l mw7 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">On keeping lots of integers in memory</h1>
      
      <p class="tracked"><strong>Gregory Trubetskoy</strong>
      </p>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-100-l"><p>ar ago) I found myself needing to store large numbers of
integers in memory. The goal was to store a graph of all our
purchasers and items purchased, so that we could quickly identify
like-minded purchasers based on common purchases and make real-time
recommendations of the form &ldquo;people like you also bought&rdquo;. This
approach is commonly known as <a href="http://en.wikipedia.org/wiki/Collaborative_filtering">collaborative filtering</a>,
and exactly how we did it would be a subject of some future post
(perhaps).</p>
<p>At the time, I was looking at tens of millions of purchases by tens of
millions people of hundreds of thousands of items. The only
information I needed to store were id&rsquo;s of people and items, which
were just integers. While this seemed like a lot of data, I
believed it was entirely feasible to store them all in memory.</p>
<p>I didn&rsquo;t have time to write my own implementation for storing this
graph, so I looked at a bunch of tools out there, asked around, and
the only one that seemed to fit the bill exactly in the end was
<a href="http://redis.io/">Redis</a>. Yes, there are a few projects out there
that tout graph storage as their specialty, but none of them could
scale anywhere close to the level I needed. And in the end the term
&ldquo;graph database&rdquo; turned out to be a red herring of sorts. Any language
such as Python, Ruby or Java provides the basic data structures
quite sufficient for storing a graph as an adjacency list
out-of-the-box. You can store a graph in any key-value store, or even
in your favorite RDBMS. (To this day I&rsquo;m not convinced there is any
good use case for the so-called graph databases out there.)</p>
<p>There were a few things that set Redis apart:</p>
<p>First, it keeps everything in RAM, which meant that updating this
dataset would be very fast, fast enough to keep it up-to-date in real
time.</p>
<p>The second great thing about Redis is <a href="http://redis.io/commands#sorted_set">Sorted Sets</a>. This data structure
and the operations it supports fit what we needed to do
precisely. (Again, sorry for sparing you the details, but roughly, you
need to store a Set of item ids for every person as well as a Set of
person ids for every item, and &ldquo;people like you&rdquo; then becomes the
union of all the Sets of items that are directly linked to &ldquo;you&rdquo;.)</p>
<p>Thirdly, Redis supports replication, which meant that if the most
CPU-intensive task of computing the actual recommendations (which
requires union-ing of a large number of large Sorted Sets) becomes a
bottle neck, we could address this by running it on slaves, and
we could easily scale the system by simply adding more slaves.</p>
<p>Last (but hardly least) is Redis&rsquo; ability to persist and quickly load
the in-memory database. You begin to appreciate the immense value of
this once you start populating Redis by pulling historical data from
your RDBMS and realize that it could take many hours or even days.</p>
<p>Everything was going great with my plan but soon I ran into a problem.
Not even a quarter of the way through the initial load process, I
noticed Redis reporting 20+ GB being used, which meant that the
particular machine I was testing this on wouldn&rsquo;t have enough
RAM. That was a bummer. Especially because it began to look like the
whole architecture would require more memory than would be financially
sensible for this project (yes, you could get a machine with 1TB of
memory, but it was and still is prohibitively expensive).</p>
<p>My hunch (supported by some quick back-of-the-napkin calculations) was
that this was a software problem, not a hardware one.</p>
<p>The first obvious inefficiency of storing integers on a 64-bit
system is how much space an integer takes up. 64 bits (or 8 bytes)
is enough to store a number as large as 92,23,372,036,854,775,807. Yet
this number takes up exactly as much memory as 17 or 1234 (pick your
favorite small number). In fact, the range of integers I was dealing
with was well under 1 billion and 32 bits would more than suffice.</p>
<p>Add to this that on a 64-bit system every <em>pointer</em> is also (you guessed
it) - 64 bits. So if you&rsquo;re storing a (singly) linked list of
integers, you end up with 8 bytes for the integer and 8 bytes for the
&ldquo;next&rdquo; pointer, or 16 bytes per integer. And if your data structure
is even more complex, such as a Redis Sorted Set, which is actually
implemented as two structures updated simultaneously (a Skip List and a
Hash), well, then you begin to see that our integers may end up taking
up as much if not less memory than the pointers pointing to them.</p>
<p>One simple way to reduce the memory bloat was to compile Redis in
32-bit mode.  Redis makes it super easy with &ldquo;make 32bit&rdquo;.  Because of
the smaller pointer size the 32-bit mode uses much less memory, but of
course the caveat is that the total address space is limited to 32
bits or about 4GB.  While this did reduce the footprint by a great
deal, it wasn&rsquo;t sufficient for my data set, which still looked to be
more than 4GB in size.</p>
<p>Then I came across this page on <a href="http://redis.io/topics/memory-optimization%22">memory optimization</a>.  Little
did I know Redis already provided a very compact way of storing
integers. For small lists, sets or hashes, Redis uses a special
structure it calls <em>ziplist</em> that can store variable-length
integers and strings. The advantage is that it is very compact, but
the flipside is that such lists can only be processed
sequentially. (This is because you can&rsquo;t access an n-th element in
such a list because sizes of elements vary, so you must scan from
beginning). But it tunrs out that sequential processing is actually
more efficient for small lists rather than following a more complex
algorithm (hashing or whatever) because it requires no
indirection and can be accomplished with simple pointer math.</p>
<p>Redis&rsquo; zset-max-ziplist-entries config setting sets a threshold - any
Sorted Set that has fewer elements than the setting is stored as a
ziplist and as soon as it reaches the number greater than the setting
it is converted to the full-fledged Sorted Set data
structure.</p>
<p>What was interesting is that in my tests bumping up the value from the
default of 128 to as high as 10000 didn&rsquo;t seem to have any noticeable
performance impact while reduced the memory usage by an order of
magnitude. My best guess is that even at 10K elements this list is
small enough to be processed entirely in the CPU cache.</p>
<p>The effect of tweaking this setting seemed like pure magic, so I just
had to dig deeper and figure out exactly how it works. You can see the
description of the format in the comments for this file in Redis
source: <a href="https://github.com/antirez/redis/blob/unstable/src/ziplist.c">src/ziplist.c</a>.</p>
<p>The technique is very simple - the first 4 bits are used to identify
the size of the integer. The relevant comment text:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">*</span> <span style="color:#f92672">|</span><span style="color:#ae81ff">11000000</span><span style="color:#f92672">|</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> byte
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> Integer encoded as <span style="color:#66d9ef">int16_t</span> (<span style="color:#ae81ff">2</span> bytes).
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> <span style="color:#f92672">|</span><span style="color:#ae81ff">11010000</span><span style="color:#f92672">|</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> byte
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> Integer encoded as <span style="color:#66d9ef">int32_t</span> (<span style="color:#ae81ff">4</span> bytes).
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> <span style="color:#f92672">|</span><span style="color:#ae81ff">11100000</span><span style="color:#f92672">|</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> byte
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> Integer encoded as <span style="color:#66d9ef">int64_t</span> (<span style="color:#ae81ff">8</span> bytes).
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> <span style="color:#f92672">|</span><span style="color:#ae81ff">11110000</span><span style="color:#f92672">|</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> byte
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> Integer encoded as <span style="color:#ae81ff">24</span> bit <span style="color:#66d9ef">signed</span> (<span style="color:#ae81ff">3</span> bytes).
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> <span style="color:#f92672">|</span><span style="color:#ae81ff">11111110</span><span style="color:#f92672">|</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> byte
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> Integer encoded as <span style="color:#ae81ff">8</span> bit <span style="color:#66d9ef">signed</span> (<span style="color:#ae81ff">1</span> byte).
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> <span style="color:#f92672">|</span><span style="color:#ae81ff">1111</span>xxxx<span style="color:#f92672">|</span> <span style="color:#f92672">-</span> (with xxxx between <span style="color:#ae81ff">0000</span> and <span style="color:#ae81ff">1101</span>) immediate <span style="color:#ae81ff">4</span> bit integer.
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> Unsigned integer from <span style="color:#ae81ff">0</span> to <span style="color:#ae81ff">12.</span> The encoded value is actually from
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span> to <span style="color:#ae81ff">13</span> because <span style="color:#ae81ff">0000</span> and <span style="color:#ae81ff">1111</span> can not be used, so <span style="color:#ae81ff">1</span> should be
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> subtracted from the encoded <span style="color:#ae81ff">4</span> bit value to obtain the right value.
</span></span></code></pre></div><p>Actually, back when I looked at it, there was no 24-bit integer
encoding, which led me to submitting a <a href="https://github.com/antirez/redis/issues/469">patch</a>, which
was gladly accepted (and corrected for <a href="http://en.wikipedia.org/wiki/Two%27s_complement">two&rsquo;s complement</a> support) by <a href="http://invece.org/">antirez</a>.</p>
<p>Since that time I&rsquo;ve been noticing different takes on variable-length
integer storage in other projects.</p>
<p>For example <a href="http://www.bitcoin.org">Bitcoin</a> uses <a href="https://en.bitcoin.it/wiki/Protocol_specification#Variable_length_integer">variable-length integers</a> to minimize the total size of the block
chain. The bitcoin algo is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#f92672">*</span> Examine at the first byte
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>  <span style="color:#f92672">-</span> If that first byte is less than <span style="color:#ae81ff">253</span>, 
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>    use the byte literally
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>  <span style="color:#f92672">-</span> If that first byte is <span style="color:#ae81ff">253</span>, read the next two bytes 
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>    as a little endian <span style="color:#ae81ff">16</span><span style="color:#f92672">-</span>bit <span style="color:#a6e22e">number</span> (total bytes read <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>  <span style="color:#f92672">-</span> If that first byte is <span style="color:#ae81ff">254</span>, read the next four bytes 
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>    as a little endian <span style="color:#ae81ff">32</span><span style="color:#f92672">-</span>bit <span style="color:#a6e22e">number</span> (total bytes read <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>  <span style="color:#f92672">-</span> If that first byte is <span style="color:#ae81ff">255</span>, read the next eight bytes 
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>   as a little endian <span style="color:#ae81ff">64</span><span style="color:#f92672">-</span>bit <span style="color:#a6e22e">number</span> (total bytes read <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>)
</span></span></code></pre></div><p><a href="http://sqlite.org/">SQLite3</a> uses its own variable-length integer format,
possibly cleverer than the two above:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">**</span> Cell content makes use of variable length integers.  A variable
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span> length integer is <span style="color:#ae81ff">1</span> to <span style="color:#ae81ff">9</span> bytes where the lower <span style="color:#ae81ff">7</span> bits of each
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span> byte are used.  The integer consists of all bytes that have bit <span style="color:#ae81ff">8</span> set and
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span> the first byte with bit <span style="color:#ae81ff">8</span> clear.  The most significant byte of the integer
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span> appears first.  A variable<span style="color:#f92672">-</span>length integer may not be more than <span style="color:#ae81ff">9</span> bytes <span style="color:#66d9ef">long</span>.
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span> As a special <span style="color:#66d9ef">case</span>, all <span style="color:#ae81ff">8</span> bytes of the <span style="color:#ae81ff">9</span>th byte are used as data.  This
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span> allows a <span style="color:#ae81ff">64</span><span style="color:#f92672">-</span>bit integer to be encoded in <span style="color:#ae81ff">9</span> bytes.
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span>    <span style="color:#ae81ff">0x00</span>                      becomes  <span style="color:#ae81ff">0x00000000</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span>    <span style="color:#ae81ff">0x7f</span>                      becomes  <span style="color:#ae81ff">0x0000007f</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span>    <span style="color:#ae81ff">0x81</span> <span style="color:#ae81ff">0x00</span>                 becomes  <span style="color:#ae81ff">0x00000080</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span>    <span style="color:#ae81ff">0x82</span> <span style="color:#ae81ff">0x00</span>                 becomes  <span style="color:#ae81ff">0x00000100</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span>    <span style="color:#ae81ff">0x80</span> <span style="color:#ae81ff">0x7f</span>                 becomes  <span style="color:#ae81ff">0x0000007f</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span>    <span style="color:#ae81ff">0x8a</span> <span style="color:#ae81ff">0x91</span> <span style="color:#ae81ff">0xd1</span> <span style="color:#ae81ff">0xac</span> <span style="color:#ae81ff">0x78</span>  becomes  <span style="color:#ae81ff">0x12345678</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span>    <span style="color:#ae81ff">0x81</span> <span style="color:#ae81ff">0x81</span> <span style="color:#ae81ff">0x81</span> <span style="color:#ae81ff">0x81</span> <span style="color:#ae81ff">0x01</span>  becomes  <span style="color:#ae81ff">0x10204081</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span> Variable length integers are used <span style="color:#66d9ef">for</span> rowids and to hold the number of
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span> bytes of key and data in a btree cell.
</span></span></code></pre></div><p>There are also other more sophisticated techniques of storing lists of integers such as
<a href="http://en.wikipedia.org/wiki/Elias_gamma">Elias encoding</a> and <a href="http://en.wikipedia.org/wiki/Golomb_coding">Golomb coding</a>.</p>
<p>����������������������������</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  Gregory Trubetskoy 2026 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
