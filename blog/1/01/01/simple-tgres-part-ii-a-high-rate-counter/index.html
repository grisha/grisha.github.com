<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Simple Tgres Part II - A High Rate Counter | Gregory Trubetskoy</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Continuing on the the previous
post on simple use of Tgres components, let&rsquo;s
try to count something that goes by really fast.
This time let&rsquo;s start out with creating a memory-based SerDe. This
means that all our data is in memory and there is no database backing
our series.
{% codeblock lang:go %}
package main
import (
&ldquo;fmt&rdquo;
&ldquo;net/http&rdquo;
&ldquo;time&rdquo;
&quot;github.com/tgres/tgres/dsl&quot;
h &quot;github.com/tgres/tgres/http&quot;
&quot;github.com/tgres/tgres/receiver&quot;
&quot;github.com/tgres/tgres/rrd&quot;
&quot;github.com/tgres/tgres/serde&quot;

)
func main() {
step := 1 * time.Second // 1 second resolution
span := 600 * step      // spanning 10 minutes

// In-memory SerDe
ms := serde.NewMemSerDe()

// Create a receiver of our data points backed by the above
// memory SerDe
rcvr := receiver.New(ms, &amp;receiver.SimpleDSFinder{&amp;rrd.DSSpec{
    Step: step,
    RRAs: []rrd.RRASpec{
        rrd.RRASpec{Function: rrd.WMEAN,
            Step: step,
            Span: span,
        },
    }}})
rcvr.Start()

{% endcodeblock %}">
    <meta name="generator" content="Hugo 0.146.0">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    <meta name="author" content="Gregory Trubetskoy">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/blog/1/01/01/simple-tgres-part-ii-a-high-rate-counter/">
    

    
    
    <meta property="og:url" content="http://localhost:1313/blog/1/01/01/simple-tgres-part-ii-a-high-rate-counter/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="Simple Tgres Part II - A High Rate Counter">
  <meta property="og:description" content="Continuing on the the previous post on simple use of Tgres components, let’s try to count something that goes by really fast.
This time let’s start out with creating a memory-based SerDe. This means that all our data is in memory and there is no database backing our series.
{% codeblock lang:go %} package main
import ( “fmt” “net/http” “time”
&#34;github.com/tgres/tgres/dsl&#34; h &#34;github.com/tgres/tgres/http&#34; &#34;github.com/tgres/tgres/receiver&#34; &#34;github.com/tgres/tgres/rrd&#34; &#34;github.com/tgres/tgres/serde&#34; )
func main() {
step := 1 * time.Second // 1 second resolution span := 600 * step // spanning 10 minutes // In-memory SerDe ms := serde.NewMemSerDe() // Create a receiver of our data points backed by the above // memory SerDe rcvr := receiver.New(ms, &amp;receiver.SimpleDSFinder{&amp;rrd.DSSpec{ Step: step, RRAs: []rrd.RRASpec{ rrd.RRASpec{Function: rrd.WMEAN, Step: step, Span: span, }, }}}) rcvr.Start() {% endcodeblock %}">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">

  <meta itemprop="name" content="Simple Tgres Part II - A High Rate Counter">
  <meta itemprop="description" content="Continuing on the the previous post on simple use of Tgres components, let’s try to count something that goes by really fast.
This time let’s start out with creating a memory-based SerDe. This means that all our data is in memory and there is no database backing our series.
{% codeblock lang:go %} package main
import ( “fmt” “net/http” “time”
&#34;github.com/tgres/tgres/dsl&#34; h &#34;github.com/tgres/tgres/http&#34; &#34;github.com/tgres/tgres/receiver&#34; &#34;github.com/tgres/tgres/rrd&#34; &#34;github.com/tgres/tgres/serde&#34; )
func main() {
step := 1 * time.Second // 1 second resolution span := 600 * step // spanning 10 minutes // In-memory SerDe ms := serde.NewMemSerDe() // Create a receiver of our data points backed by the above // memory SerDe rcvr := receiver.New(ms, &amp;receiver.SimpleDSFinder{&amp;rrd.DSSpec{ Step: step, RRAs: []rrd.RRASpec{ rrd.RRASpec{Function: rrd.WMEAN, Step: step, Span: span, }, }}}) rcvr.Start() {% endcodeblock %}">
  <meta itemprop="wordCount" content="403">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Simple Tgres Part II - A High Rate Counter">
  <meta name="twitter:description" content="Continuing on the the previous post on simple use of Tgres components, let’s try to count something that goes by really fast.
This time let’s start out with creating a memory-based SerDe. This means that all our data is in memory and there is no database backing our series.
{% codeblock lang:go %} package main
import ( “fmt” “net/http” “time”
&#34;github.com/tgres/tgres/dsl&#34; h &#34;github.com/tgres/tgres/http&#34; &#34;github.com/tgres/tgres/receiver&#34; &#34;github.com/tgres/tgres/rrd&#34; &#34;github.com/tgres/tgres/serde&#34; )
func main() {
step := 1 * time.Second // 1 second resolution span := 600 * step // spanning 10 minutes // In-memory SerDe ms := serde.NewMemSerDe() // Create a receiver of our data points backed by the above // memory SerDe rcvr := receiver.New(ms, &amp;receiver.SimpleDSFinder{&amp;rrd.DSSpec{ Step: step, RRAs: []rrd.RRASpec{ rrd.RRASpec{Function: rrd.WMEAN, Step: step, Span: span, }, }}}) rcvr.Start() {% endcodeblock %}">

	
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$', '$'] ],
      displayMath: [ ['$$', '$$']],
      processEscapes: true,
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Gregory Trubetskoy
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/archives/" title="Archives page">
              Archives
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l mw7 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Simple Tgres Part II - A High Rate Counter</h1>
      
      <p class="tracked"><strong>Gregory Trubetskoy</strong>
      </p>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-100-l"><p>Continuing on the <a href="/blog/2016/12/21/simple-time-series-app-with-tgres/">the previous</a>
post on simple use of <a href="https://github.com/tgres/tgres">Tgres</a> components, let&rsquo;s
try to count something that goes by really fast.</p>
<p>This time let&rsquo;s start out with creating a memory-based SerDe. This
means that all our data is in memory and there is no database backing
our series.</p>
<p>{% codeblock lang:go %}
package main</p>
<p>import (
&ldquo;fmt&rdquo;
&ldquo;net/http&rdquo;
&ldquo;time&rdquo;</p>
<pre><code>&quot;github.com/tgres/tgres/dsl&quot;
h &quot;github.com/tgres/tgres/http&quot;
&quot;github.com/tgres/tgres/receiver&quot;
&quot;github.com/tgres/tgres/rrd&quot;
&quot;github.com/tgres/tgres/serde&quot;
</code></pre>
<p>)</p>
<p>func main() {</p>
<pre><code>step := 1 * time.Second // 1 second resolution
span := 600 * step      // spanning 10 minutes

// In-memory SerDe
ms := serde.NewMemSerDe()

// Create a receiver of our data points backed by the above
// memory SerDe
rcvr := receiver.New(ms, &amp;receiver.SimpleDSFinder{&amp;rrd.DSSpec{
    Step: step,
    RRAs: []rrd.RRASpec{
        rrd.RRASpec{Function: rrd.WMEAN,
            Step: step,
            Span: span,
        },
    }}})
rcvr.Start()
</code></pre>
<p>{% endcodeblock %}</p>
<p>Now let&rsquo;s create a goroutine which creates data points as fast as it
can, the difference from the previous blog post is that we are using
QueueGauge(), which is a <em>paced metric</em>, meaning that it flushes to the
time series only periodically (once per second by default) so as to
not overwhelm the I/O and or network (even though in this case it doesn&rsquo;t
really matter since we&rsquo;re using a memory-based SerDe anyway).</p>
<p>{% codeblock lang:go %}
start := time.Now()
end := start.Add(span)</p>
<pre><code>go func() {
    n := 0
    for t := time.Now(); t.Before(end); t = time.Now() {
        rcvr.QueueGauge(serde.Ident{&quot;name&quot;:&quot;foo.bar&quot;}, float64(n)/(t.Sub(start)).Seconds())
        n++
    }
}()
</code></pre>
<p>{% endcodeblock %}</p>
<p>And finally, as before, we need to hook up a couple of http handlers:</p>
<p>{% codeblock lang:go %}
db := dsl.NewNamedDSFetcher(ms.Fetcher())</p>
<pre><code>http.HandleFunc(&quot;/metrics/find&quot;, h.GraphiteMetricsFindHandler(db))
http.HandleFunc(&quot;/render&quot;, h.GraphiteRenderHandler(db))

listenSpec := &quot;:8088&quot;
fmt.Printf(&quot;Waiting for requests on %s\n&quot;, listenSpec)
http.ListenAndServe(listenSpec, nil)
</code></pre>
<p>} // end of main()
{% endcodeblock %}</p>
<p>Now if we run the above code with something like
<code>go run simpletgres.go</code>, we&rsquo;ll notice that unlike with the previous
example, the web server starts right away, and the data points are
being written while the server is running. If we aim Grafana at it,
we should be able to see the chart update in real time.</p>
<p>After a couple of minutes, mine looks like this:</p>
<p>{% img /images/simple-tgres01.png %}</p>
<p>So my macbook can crank these out at about 2.5 million per second.</p>
<p>In my experience instrumenting my apps with simple counters like this
and having them available directly from the app without having to send
them to a separate statsd server somewhere has been extremely useful in
helping understand performance and other issues.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  Gregory Trubetskoy 2026 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
