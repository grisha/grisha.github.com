<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Storing Time Series in PostgreSQL (Continued) | Gregory Trubetskoy</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Edit: there is now a part iii in this series of articles.
I have previously written how
time series can be stored in PostgreSQL efficiently using arrays.
As a continuation of that article, I shall attempt to describe in detail the inner workings of an
SQL view that Tgres uses to
make an array of numbers appear as a regular table
(link to code).
In short, I will explain how incomprehensible data like this:
{% codeblock lang:sql %}
=&gt; select * from ts;
rra_id | n |           dp
&mdash;&mdash;&ndash;&#43;&mdash;&#43;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
1 | 0 | {64,67,70,71,72,69,67}
1 | 1 | {65,60,58,59,62,68,70}
1 | 2 | {71,72,77,70,71,73,75}
1 | 3 | {79,82,90,69,75,80,81}
{% endcodeblock %}">
    <meta name="generator" content="Hugo 0.146.0">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    <meta name="author" content="Gregory Trubetskoy">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/blog/1/01/01/storing-time-series-in-postgresql-continued/">
    

    
    
    <meta property="og:url" content="http://localhost:1313/blog/1/01/01/storing-time-series-in-postgresql-continued/">
  <meta property="og:site_name" content="Gregory Trubetskoy">
  <meta property="og:title" content="Storing Time Series in PostgreSQL (Continued)">
  <meta property="og:description" content="Edit: there is now a part iii in this series of articles.
I have previously written how time series can be stored in PostgreSQL efficiently using arrays.
As a continuation of that article, I shall attempt to describe in detail the inner workings of an SQL view that Tgres uses to make an array of numbers appear as a regular table (link to code).
In short, I will explain how incomprehensible data like this:
{% codeblock lang:sql %} =&gt; select * from ts; rra_id | n | dp ——–&#43;—&#43;———————— 1 | 0 | {64,67,70,71,72,69,67} 1 | 1 | {65,60,58,59,62,68,70} 1 | 2 | {71,72,77,70,71,73,75} 1 | 3 | {79,82,90,69,75,80,81} {% endcodeblock %}">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">

  <meta itemprop="name" content="Storing Time Series in PostgreSQL (Continued)">
  <meta itemprop="description" content="Edit: there is now a part iii in this series of articles.
I have previously written how time series can be stored in PostgreSQL efficiently using arrays.
As a continuation of that article, I shall attempt to describe in detail the inner workings of an SQL view that Tgres uses to make an array of numbers appear as a regular table (link to code).
In short, I will explain how incomprehensible data like this:
{% codeblock lang:sql %} =&gt; select * from ts; rra_id | n | dp ——–&#43;—&#43;———————— 1 | 0 | {64,67,70,71,72,69,67} 1 | 1 | {65,60,58,59,62,68,70} 1 | 2 | {71,72,77,70,71,73,75} 1 | 3 | {79,82,90,69,75,80,81} {% endcodeblock %}">
  <meta itemprop="wordCount" content="1339">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Storing Time Series in PostgreSQL (Continued)">
  <meta name="twitter:description" content="Edit: there is now a part iii in this series of articles.
I have previously written how time series can be stored in PostgreSQL efficiently using arrays.
As a continuation of that article, I shall attempt to describe in detail the inner workings of an SQL view that Tgres uses to make an array of numbers appear as a regular table (link to code).
In short, I will explain how incomprehensible data like this:
{% codeblock lang:sql %} =&gt; select * from ts; rra_id | n | dp ——–&#43;—&#43;———————— 1 | 0 | {64,67,70,71,72,69,67} 1 | 1 | {65,60,58,59,62,68,70} 1 | 2 | {71,72,77,70,71,73,75} 1 | 3 | {79,82,90,69,75,80,81} {% endcodeblock %}">

	
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$', '$'] ],
      displayMath: [ ['$$', '$$']],
      processEscapes: true,
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Gregory Trubetskoy
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/archives/" title="Archives page">
              Archives
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l mw7 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Storing Time Series in PostgreSQL (Continued)</h1>
      
      <p class="tracked"><strong>Gregory Trubetskoy</strong>
      </p>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-100-l"><p>Edit: there is now a <a href="/blog/2017/01/21/storing-time-seris-in-postgresql-optimize-for-write">part iii</a> in this series of articles.</p>
<p>I have <a href="/blog/2015/09/23/storing-time-series-in-postgresql-efficiently/">previously written</a> how
time series can be stored in PostgreSQL efficiently using <a href="https://www.postgresql.org/docs/current/static/arrays.html">arrays</a>.</p>
<p>As a continuation of that article, I shall attempt to describe in detail the inner workings of an
<a href="https://en.wikipedia.org/wiki/View_(SQL)">SQL view</a> that <a href="https://github.com/tgres/tgres">Tgres</a> uses to
make an array of numbers appear as a regular table
(<a href="https://github.com/tgres/tgres/blob/bc718e3999650b7aab934517179ea47632530d28/serde/postgres.go#L235-L242">link to code</a>).</p>
<p>In short, I will explain how incomprehensible data like this:</p>
<p>{% codeblock lang:sql %}
=&gt; select * from ts;
rra_id | n |           dp
&mdash;&mdash;&ndash;+&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
1 | 0 | {64,67,70,71,72,69,67}
1 | 1 | {65,60,58,59,62,68,70}
1 | 2 | {71,72,77,70,71,73,75}
1 | 3 | {79,82,90,69,75,80,81}
{% endcodeblock %}</p>
<p>&hellip; can be transformed in an SQL view to appear as so:</p>
<p>{% codeblock lang:sql %}
=&gt; select * from tv order by t;
rra_id |           t            | r
&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;-
1 | 2008-03-06 00:00:00+00 | 64
1 | 2008-03-07 00:00:00+00 | 67
1 | 2008-03-08 00:00:00+00 | 70
1 | 2008-03-09 00:00:00+00 | 71
&hellip;
{% endcodeblock %}</p>
<p>This write up will make a lot more sense if you read the
<a href="/blog/2015/09/23/storing-time-series-in-postgresql-efficiently/">previous post</a> first.
To recap, Tgres stores series in an array broken up over multiple
table rows each containing an array representing a segment of the
series. The series array is a round-robin structure, which means
that it occupies a fixed amount of space and we do not need to worry
about expiring data points: the round-robin nature of the array
takes care of it by overwriting old data with new on assignment.</p>
<p>An additional benefit of such a fixed interval round-robin structure
is that we do not need to store timestamps for every data point. If we
know the timestamp of the latest entry along with the series step and size,
we can extrapolate the timestamp of any point in the series.</p>
<p>Tgres creates an SQL view which takes care of this extrapolation and
makes this data easy to query. Tgres actually uses this view as its
only source of time series information when reading from the database
thus delegating all the processing to the database server, where it is
close to the data and most efficient.</p>
<p>If you would like to follow along on the Postgres command line, feel
free to create and populate the tables with the following SQL, which
is nearly identical to the schema used by Tgres:</p>
<p>{% codeblock lang:sql %}
CREATE TABLE rra (
id SERIAL NOT NULL PRIMARY KEY,
step_s INT NOT NULL,
steps_per_row INT NOT NULL,
size INT NOT NULL,
width INT NOT NULL,
latest TIMESTAMPTZ DEFAULT NULL);</p>
<p>CREATE TABLE ts (
rra_id INT NOT NULL,
n INT NOT NULL,
dp DOUBLE PRECISION[] NOT NULL DEFAULT &lsquo;{}&rsquo;);</p>
<p>INSERT INTO rra VALUES (1, 60, 1440, 28, 7, &lsquo;2008-04-02 00:00:00-00&rsquo;);</p>
<p>INSERT INTO ts VALUES (1, 0, &lsquo;{64,67,70,71,72,69,67}&rsquo;);
INSERT INTO ts VALUES (1, 1, &lsquo;{65,60,58,59,62,68,70}&rsquo;);
INSERT INTO ts VALUES (1, 2, &lsquo;{71,72,77,70,71,73,75}&rsquo;);
INSERT INTO ts VALUES (1, 3, &lsquo;{79,82,90,69,75,80,81}&rsquo;);
{% endcodeblock %}</p>
<p>And finally create the view:</p>
<p>{% codeblock lang:sql %}
CREATE VIEW tv AS
SELECT rra.id rra_id,
latest - INTERVAL &lsquo;1 SECOND&rsquo; * rra.step_s * rra.steps_per_row *
MOD(rra.size + MOD(EXTRACT(EPOCH FROM rra.latest)::BIGINT/(rra.step_s * rra.steps_per_row), size) + 1
- (generate_subscripts(dp,1) + n * width), rra.size) AS t,
UNNEST(dp) AS r
FROM rra
INNER JOIN ts ts ON ts.rra_id = rra.id;
{% endcodeblock %}</p>
<p>Now give it a whirl with a <code>SELECT * FROM tv ORDER BY t</code>. Impressive? So how does it work?</p>
<p>First let&rsquo;s go over the columns of the rra table.</p>
<ul>
<li><code>step_s</code>: the minimal unit of time expressed in seconds (60 or 1 minute in the above data).</li>
<li><code>steps_per_row</code>: the number of the <code>step_s</code> intervals in one slot of our time series.
In our example it is 1440, which is the number of minutes in a day, thus making our time series
resolution <em>one day</em>.</li>
<li><code>size</code>: number of slots in the series. Ours is 28, i.e. four weeks.</li>
<li><code>width</code>: size of a segment which will be stored in a single row, which in our case
is 7 (one week).</li>
<li><code>latest</code>: the timestamp of the last data point in the series.</li>
</ul>
<p>Next, let&rsquo;s look at the <code>UNNEST</code> keyword in the SQL of the view. <code>UNNEST</code> takes an array and turns it into row, e.g.:</p>
<h2 id="r">{% codeblock lang:sql %}
=&gt; SELECT UNNEST(dp) AS r FROM ts;
r</h2>
<p>64
67
&hellip;
{% endcodeblock %}</p>
<p><code>UNNEST</code> works in conjunction with the <code>generate_subscripts</code>
PostgreSQL function which generates index values:</p>
<p>{% codeblock lang:sql %}
=&gt; SELECT generate_subscripts(dp,1) AS i, UNNEST(dp) AS r FROM ts;
i | r
&mdash;+&mdash;-
1 | 64
2 | 67
&hellip;
{% endcodeblock %}</p>
<p>Let us now zoom in on the very long expression in the view, here it is again:</p>
<p>{% codeblock lang:sql %}
latest - INTERVAL &lsquo;1 SECOND&rsquo; * rra.step_s * rra.steps_per_row *
MOD(rra.size + MOD(EXTRACT(EPOCH FROM rra.latest)::BIGINT/(rra.step_s * rra.steps_per_row), size) + 1</p>
<ul>
<li>(generate_subscripts(dp,1) + n * width), rra.size) AS t
{% endcodeblock %}</li>
</ul>
<p>A perhaps not immediately apparent trick to how all this works is that all
our series are aligned
on the <a href="https://en.wikipedia.org/wiki/Unix_time">beginning of the epoch</a>.
This means that at UNIX time 0, any series&rsquo; slot index is 0. From then on it
increments sequentially until the series size is reached, at which point
it wraps-around to 0 (thus &ldquo;round-robin&rdquo;). Armed with this information we
can calculate the index for any point in time.</p>
<p>The formula for calculating the index <code>i</code> for a given time <code>t</code> is:
{% codeblock lang:python %}
i = t/step % size.
{% endcodeblock %}</p>
<p>We need time to be expressed as a UNIX time which is done
with <code>EXTRACT(EPOCH FROM rra.latest)::BIGINT</code>. Now you should recognize
the above formula in the more verbose expression
{% codeblock lang:sql %}
MOD(EXTRACT(EPOCH FROM rra.latest)::BIGINT/(rra.step_s * rra.steps_per_row), size)
{% endcodeblock %}
where <code>rra.step_s * rra.steps_per_row</code> is the size of our series in seconds.</p>
<p>Next, we need to compute the <em>distance</em> between the current slot and the
last slot (for which we know the timestamp). I.e. if the last slot is <code>i</code> and the slot we need the
timestamp for is <code>j</code>, the distance between them is <code>i-j</code>, but with a
caveat: it is possible for <code>j</code> to be greater than <code>i</code> if the series
wraps around, in which case the distance is the sum of the distance from
<code>j</code> to the end of the series and the distance from the beginning to
<code>i</code>. If you ponder over it with a pencil and paper long enough, you
will arrive at the following formula for distance between two slots
<code>i</code> and <code>j</code> in a wrap-around array:</p>
<p>{% codeblock lang:python %}
distance = (size + i - j) % size
{% endcodeblock %}</p>
<p>Another thing to consider is that we&rsquo;re splitting our series across
multiple rows, thus the actual index of any point is the subscript
into the current segment plus the index of the segment itself (the <code>n</code>
column) multiplied by the <code>wdith</code> of the segment: <code>generate_subscripts(dp,1) + n * width</code>.</p>
<p>Which pieced together in SQL now looks like this:</p>
<p>{% codeblock lang:sql %}
MOD(rra.size + MOD(EXTRACT(EPOCH FROM rra.latest)::BIGINT/(rra.step_s * rra.steps_per_row), size) + 1</p>
<ul>
<li>(generate_subscripts(dp,1) + n * width), rra.size)
{% endcodeblock %}</li>
</ul>
<p>Astute readers should notice an unexplained <code>+ 1</code>. This is because
PostgreSQL arrays are 1-based.</p>
<p>Now we need to convert the distance expressed in array slots into
a time interval, which we do by multiplying it by
<code>INTERVAL '1 SECOND' * rra.step_s * rra.steps_per_row</code>.</p>
<p>And finally, we need to subtract the above time interval from the
latest stamp which yields (ta-da!) the timestamp of the current slot:</p>
<p>{% codeblock lang:sql %}
latest - INTERVAL &lsquo;1 SECOND&rsquo; * rra.step_s * rra.steps_per_row *
MOD(rra.size + MOD(EXTRACT(EPOCH FROM rra.latest)::BIGINT/(rra.step_s * rra.steps_per_row), size) + 1</p>
<ul>
<li>(generate_subscripts(dp,1) + n * width), rra.size) AS t
{% endcodeblock %}</li>
</ul>
<p>That&rsquo;s it! And even though this may look complicated, from the
computational view point it is very efficient, and PostgreSQL can
handle it easily.</p>
<p>As an exercise, try setting <code>latest</code> to various timestamps and observe
how it affects the output of the view and see if you can explain how
and why it happens.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  Gregory Trubetskoy 2026 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
